{
  "schemaVersion": "1.0",
  "version": "1.0.18",
  "name": "Microsoft Ruleset",
  "rules": [
    {
      "id": "AutoCreateStats",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Statistics", "QueryOptimizer" ],
      "displayName": "Auto-Create Statistics should be on",
      "description": "The Query Optimizer determines whether an index is useful for a specific query by evaluating the stored statistics. If the statistics become out of date and significant changes have occurred against the underlying data, this can result in less than optimal query performance. In most cases, it's best to let SQL Server maintain the statistics. If you turn 'Auto Create Stats' and 'Auto Update Stats' off, then it is up to you to keep the statistics up-to-date somehow. Failure to do so will lead to poor query performance. Most applications should have these options ON. When the Auto Create statistics setting is ON, the Query Optimizer creates statistics on one or more columns of a table or an indexed view, as necessary, to improve query plans and query performance.",
      "message": "Turn Auto-Create Statistics option on to improve query performance.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/statistics/statistics#CreateStatistics",
      "probes": [ "DatabaseConfiguration" ],
      "condition": "@is_auto_create_stats_on"
    },
    {
      "id": "AutoUpdateStats",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Statistics", "QueryOptimizer" ],
      "displayName": "Auto-Update Statistics should be on",
      "description": "The Query Optimizer determines whether an index is useful for a specific query by evaluating the stored statistics. If the statistics become out of date and significant changes have occurred against the underlying data, this can result in less than optimal query performance. In most cases, it's best to let SQL Server maintain the statistics. If you turn 'Auto Create Stats' and 'Auto Update Stats' off, then it is up to you to keep the statistics up-to-date somehow. Failure to do so will lead to poor query performance. Most applications should have these options ON. When the Auto Update Statistics setting is ON, the Query Optimizer updates statistics when they are used by a query and when they might be out-of-date. Statistics become out-of-date after insert, update, delete, or merge operations change the data distribution in the table or indexed view. The Query Optimizer determines when statistics might be out-of-date by counting the number of data modifications since the last statistics update and comparing the number of modifications to a threshold. The threshold is based on the number of rows in the table or indexed view. The Query Optimizer checks for out-of-date statistics before compiling a query and before executing a cached query plan. Before compiling a query, the Query Optimizer uses the columns, tables, and indexed views in the query predicate to determine which statistics might be out-of-date. Before executing a cached query plan, the Database Engine verifies that the query plan references up-to-date statistics. The AUTO_UPDATE_STATISTICS option applies to statistics created for indexes, single-columns in query predicates, and statistics that are created by using the CREATE STATISTICS statement. This option also applies to filtered statistics.",
      "message": "Turn Auto-Update Statistics option on to improve query performance.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/statistics/statistics#UpdateStatistics",
      "probes": [ "DatabaseConfiguration" ],
      "condition": "@is_auto_update_stats_on"
    },
    {
      "id": "QueryStoreOn",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "version": "[13.0,)",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "tempdb", "model"] }
      },
      "tags": [ "DefaultRuleset", "Performance", "QueryStore", "Statistics" ],
      "displayName": "Query Store should be active",
      "description": "The Query Store feature provides you with insight on query plan choice and performance. It simplifies performance troubleshooting by helping you quickly find performance differences caused by query plan changes. Query Store automatically captures a history of queries, plans, and runtime statistics, and retains these for your review. It separates data by time windows so you can see database usage patterns and understand when query plan changes happened on the server. While Query Store collects queries, execution plans and statistics, its size in the database grows until this limit is reached. When that happens, Query Store automatically changes the operation mode to read-only and stops collecting new data, which means that your performance analysis is no longer accurate.",
      "message": "Make sure Query Store actual operation mode is 'Read Write' to keep your performance analysis accurate",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store",
      "probes": [ "DatabaseConfiguration" ],
      "condition": {
        "equal": [ "@query_store_state", 2 ]
      }
    },
    {
      "id": "TF174",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": [
          "[11.0.3368,12.0)",
          "[12.0.2480,13.0)",
          "[13.0,)"
        ],
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Memory", "Performance" ],
      "displayName": "TF 174 increases the plan cache bucket count",
      "description": "Trace Flag 174 increases the SQL Server plan cache bucket count from 40,009 to 160,001 on 64-bit systems.\n When the SQL Server plan cache reaches its entry limit, plans that have low cost must be evicted in order to insert new plans. This can cause severe contention on the SOS_CACHESTORE spinlock and a high CPU usage occurs in SQL Server.\n On 64-bit systems, the number of buckets for the SQL Server plan cache is 40,009. Therefore, the maximum number of entries that can fit inside the SQL Server plan cache is 160,036. Enabling trace flag 174 on high performance systems increases the size of the cache and can avoid SOS_CACHESTORE spinlock contention.",
      "message": "Consider enabling trace flag 174 to increase the plan cache bucket count.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 174, "@TraceFlag" ]
      }
    },
    {
      "id": "TF634",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Memory", "Performance", "ColumnStore" ],
      "displayName": "TF 634 disables background columnstore compression",
      "description": "Trace Flag 634 disables the background columnstore compression task.\n SQL Server periodically runs the Tuple Mover background task that compresses columnstore index rowgroups with uncompressed data, one such rowgroup at a time.\n Columnstore compression improves query performance but also consumes system resources.\n You can control the timing of columnstore compression manually, by disabling the background compression task with trace flag 634, and then explicitly invoking ALTER INDEX...REORGANIZE or ALTER INDEX...REBUILD at the time of your choice.",
      "message": "Trace Flag 634 disables the background columnstore compression task. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 634, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF652",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "Memory", "Pages" ],
      "displayName": "TF 652 disables page pre-fetching scans",
      "description": "Trace Flag 652 disables page pre-fetching for scans.\n The read-ahead process reads the full extent of a referenced database page into the buffer pool, before those contiguous database pages are consumed by scans.\n Enabling the trace flag can lead to performance issues on queries that leverage pre-fetching.",
      "message": "Trace Flag 652 disables Page Pre-fetching Scans. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "http://support.microsoft.com/kb/920093",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 652, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF661",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 661 disables Ghost Cleanup Task",
      "description": "Trace Flag 661 disables the ghost record removal process. A ghost record is the result of a delete operation.\n When you delete a record, the deleted record is kept as a ghost record. Later, the deleted record is purged by the ghost record removal process. When you disable this process, the deleted record is not purged.\n Therefore, the space that the deleted record consumes is not freed. This behavior affects space consumption and the performance of scan operations.\n If you turn off this trace Flag, the ghost record removal process works correctly.",
      "message": "Trace flag 661 disables the background ghost cleanup task. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/920093",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 661, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF834",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "Memory", "ColumnStore" ],
      "displayName": "TF 834 enables large-page allocations",
      "description": "Trace Flag 834 causes the server to use large-page memory (LPM) model for the buffer pool allocations. Consider enabling TF 834 if you have a server that has a lot of memory, particularly for an analytical or data warehousing workload. Trace flag 834 is NOT recommended on SQL Server instances that use columnstore indexes.",
      "message": "Enable trace flag 834 to use large-page allocations to improve analytical and data warehousing workloads.",
      "helpLink": "https://support.microsoft.com/help/4465518",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 834, "@TraceFlag" ]
      }
    },
    {
      "id": "TF845",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Memory", "Performance" ],
      "displayName": "TF 845 is not needed in SQL Server 2012 and higher versions",
      "description": "Trace Flag 845 supports locking pages in memory in SQL Server Standard edition, which is needed together with trace flag 834 to use the large-page memory (LPM) model for the buffer pool allocations.\n  Consider enabling TF 834 if you have a server that has a lot of memory, particularly for an analytical or data warehousing workload.\n Starting with SQL Server 2012 this behavior is enabled by default for Standard edition, and trace flag 845 must not be used.",
      "message": "Disable trace flag 845 in SQL Server 2012 and higher versions.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 845, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF902",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "UpdateIssues" ],
      "displayName": "TF 902: Database Upgrade Bypass should be disabled",
      "description": "Trace Flag 902 bypasses execution of database upgrade script when installing a Cumulative Update or Service Pack.\n This trace flag is not supported to run it continuously in a production environment.\n If you encounter an error during script upgrade mode, it is recommended to contact Microsoft SQL Customer Service and Support (CSS) for further guidance.",
      "message": "Disable trace flag 902 which bypasses database upgrade.",
      "helpLink": "https://support.microsoft.com/help/2163980",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 902, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1117",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "DBFileConfiguration", "Performance" ],
      "displayName": "TF 1117 Enables Filegroup-level Autogrow",
      "description": "Trace Flag 1117 initiates the growth of every file in the filegroup, when a file in the filegroup meets the autogrow threshold, and together with trace flag 1118, can help reduce allocation contention in the SQL Server TempDB database.\n This trace flag affects all databases and is recommended only if every database is safe to be grow all files in a filegroup by the same amount.",
      "message": "Consider enabling trace flag 1117 to enable filegroup autogrow.",
      "helpLink": "https://support.microsoft.com/help/2154845",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 1117, "@TraceFlag" ]
      }
    },
    {
      "id": "TF1117",
      "itemType": "override",
      "targetFilter": {
        "version": "[13.0,)"
      },
      "displayName": "TF 1117 has no effect in SQL Server 2016 and higher versions",
      "description": "Trace Flag 1117 initiates the growth of every file in the filegroup, when a file in the filegroup meets the autogrow threshold, and together with trace flag 1118, can help reduce allocation contention in the SQL Server TempDB database.\n Starting with SQL Server 2016, this behavior is controlled by the AUTOGROW_SINGLE_FILE and AUTOGROW_ALL_FILES options of ALTER DATABASE syntax.",
      "message": "Disable trace flag 1117 in SQL Server 2016 and higher versions.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options",
      "condition": {
        "not": {
          "in": [ 1117, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1118",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Memory", "Performance", "Pages" ],
      "displayName": "TF 1118 Disables Single Page Allocations",
      "description": "Trace Flag 1118 forces page allocations on uniform extents instead of mixed extents, and together with trace flag 1117, can help reduce allocation contention in the SQL Server TempDB database.\n When a new object is created, by default, the first eight pages are allocated from different extents (mixed extents).\n Afterwards, when more pages are needed, those are allocated from that same extent (uniform extent).\n The SGAM page is used to track these mixed extents, so can quickly become a bottleneck when numerous mixed page allocations are occurring.\n This trace flag allocates all eight pages from the same extent when creating new objects, minimizing the need to scan the SGAM page and forces uniform extent allocations instead of mixed page allocations.",
      "message": "Consider enabling trace flag 1118 to force page allocations on uniform extents.",
      "helpLink": "https://support.microsoft.com/help/328551",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 1118, "@TraceFlag" ]
      }
    },
    {
      "id": "TF1118",
      "itemType": "override",
      "targetFilter": {
        "version": "[13.0,)"
      },
      "displayName": "TF 1118 has no effect in SQL Server 2016 and higher versions",
      "description": "Trace Flag 1118 forces page allocations on uniform extents instead of mixed extents, and together with trace flag 1117, can help reduce allocation contention in the SQL Server TempDB database.\n When a new object is created, by default, the first eight pages are allocated from different extents (mixed extents).\n Afterwards, when more pages are needed, those are allocated from that same extent (uniform extent).\n The SGAM page is used to track these mixed extents, so can quickly become a bottleneck when numerous mixed page allocations are occurring.\n This trace flag allocates all eight pages from the same extent when creating new objects, minimizing the need to scan the SGAM page and forces uniform extent allocations instead of mixed page allocations.\n Starting with SQL Server 2016, this behavior is controlled by the SET MIXED_PAGE_ALLOCATION option of ALTER DATABASE syntax.",
      "message": "Disable trace flag 1118 in SQL Server 2016 and higher versions.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options",
      "condition": {
        "not": {
          "in": [ 1118, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1204",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Locks", "Performance" ],
      "displayName": "TF 1204 returns deadlock information",
      "description": "Trace Flag 1204 returns the resources and types of locks that are participating in a deadlock, including the affected command.\n The resulting information is recorded in the SQL Server Errorlog.",
      "message": "Trace Flag 1204 returns deadlock information.",
      "helpLink": "https://support.microsoft.com/help/832524",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 1204, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1211",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Locks", "Performance" ],
      "displayName": "TF 1211: Lock Escalation should be enabled",
      "description": "Trace Flag 1211 disables lock escalation based on memory pressure, or based on number of locks. Because SQL Server will not escalate row or page locks to table locks, this can generate an excessive number of locks. If the lock memory grows large enough, attempts to allocate additional locks for any query may fail and cause performance issues.\n This trace flag should not be used in order to avoid inability to allocate lock resources because of insufficient memory. If lock escalation needs to be disabled, use trace flag 1224 instead.",
      "message": "Disable trace flag 1211 to allow lock escalation.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 1211, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1222",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Locks", "Performance" ],
      "displayName": "TF 1222 returns deadlock information",
      "description": "Trace Flag 1222 returns the resources and types of locks that are participating in a deadlock, including the affected command.\n The resulting information is recorded in the SQL Server Errorlog, in XML format that does not comply with any XSD schema.",
      "message": "Trace Flag 1222 returns deadlock information.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 1222, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1224",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Locks", "Performance" ],
      "displayName": "TF 1224 should be disabled",
      "description": "Trace Flag 1224 disables lock escalation based on the number of locks, unless SQL Server is under memory pressure. Because SQL Server will not escalate row or page locks to table locks, this can generate an excessive number of locks.",
      "message": "Disable trace flag 1224 to allow lock escalation.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 1224, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1229",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Locks", "Performance", "CPU" ],
      "displayName": "TF 1229: Lock Partitioning should be enabled",
      "description": "Trace Flag 1229 disables lock partitioning regardless of the number of CPUs. By default, SQL Server enables lock partitioning when a server has 16 or more CPUs, to improve the scalability characteristics of larger systems.\n Disabling lock partitioning may cause can cause spinlock contention and poor performance, or unexpected behaviors when switching partitions.",
      "message": "Disable trace flag 1229 to allow lock partitioning.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 1229, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1236",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Locks", "Performance" ],
      "displayName": "TF 1236: Database Lock Partitioning should be enabled",
      "description": "Trace Flag 1236 enables database-level lock partitioning.\n Lock Partitioning is utilized to improve the scalability characteristics on larger systems.",
      "message": "Enable trace Flag 1236 to allow database lock partitioning.",
      "helpLink": "https://support.microsoft.com/help/2926217",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 1236, "@TraceFlag" ]
      }
    },
    {
      "id": "TF1236",
      "itemType": "override",
      "targetFilter": {
        "version": [ "[11.0.6020,12.0)", "[12.0.4100,)" ]
      },
      "displayName": "TF 1236 is not needed in SQL Server 2012 SP3, SQL Server 2014 SP1 and higher versions",
      "description": "Trace Flag 1236 enables database-level lock partitioning.\n Starting with SQL Server 2012 SP3 and SQL Server 2014 SP1, this behavior is controlled by the engine and trace flag 1236 has no effect.",
      "message": "Disable trace flag 1236 in SQL Server 2012 SP3, SQL Server 2014 SP1 and higher versions.",
      "condition": {
        "not": {
          "in": [ 1236, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF1462",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "AvailabilityGroups" ],
      "displayName": "TF 1462 should be disabled to allow Log Stream Compression",
      "description": "Trace Flag 1462 disables log stream compression for asynchronous availability groups.\n This feature is enabled by default on asynchronous replicas to optimize network bandwidth.",
      "message": "Disable trace flag 1462 to allow log stream compression.",
      "helpLink": "https://docs.microsoft.com/sql/database-engine/availability-groups/windows/tune-compression-for-availability-group",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 1462, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2312",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "displayName": "TF 2312 sets the default Cardinality Estimation model",
      "description": "Trace Flag 2312 sets the Query Optimizer cardinality estimation model to the default version of the database compability level of SQL Server 2014 and higher versions. If the database compatibility level is lower than 120, enabling trace flag 2312 uses the cardinality estimation model of SQL Server 2014 (120).",
      "message": "Trace Flag 2312 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2801413",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 2312, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2312",
      "itemType": "override",
      "targetFilter": {
        "version": "[12.0, 13.0)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "level": "Information"
    },
    {
      "id": "TF2312",
      "itemType": "override",
      "targetFilter": {
        "version": "[13.0, )"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "message": "TF2312 enables New CE model to SQL Server 2014 or above versions, dependent of the compatibility level of the database",
      "level": "Information"
    },
    {
      "id": "TF2330",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,)",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "Indexes" ],
      "displayName": "TF 2330 disables recording of index usage stats",
      "description": "Trace Flag 2330 disables recording of index usage stats, which could lead to a non-yielding condition in SQL 2005.",
      "message": "Trace Flag 2330 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://blogs.msdn.microsoft.com/ialonso/2012/10/08/faq-around-sys-dm_db_index_usage_stats",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 2330, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2340",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "displayName": "TF 2340 disables Batch Sorts for optimized nested loops joins",
      "description": "Trace Flag 2340 causes SQL Server not to use a sort operation (batch sort) for optimized nested loops joins when generating a plan.\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 2340 disables Batch Sorts for optimized nested loops joins.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 2340, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2371",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "Statistics" ],
      "displayName": "TF 2371 enables a linear recompilation threshold for statistics",
      "description": "Trace Flag 2371 causes SQL Server to change the fixed update statistics threshold to a linear update statistics threshold.\n This is especially useful to keep statistics updated on large tables.",
      "message": "Enable trace Flag 2371 to allow a linear recompilation threshold for statistics.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 2371, "@TraceFlag" ]
      }
    },
    {
      "id": "TF2371",
      "itemType": "override",
      "targetFilter": {
        "version": "[13.0,)"
      },
      "displayName": "TF 2371 has no effect in SQL Server 2016 and higher versions",
      "description": "Trace Flag 2371 causes SQL Server to change the fixed update statistics threshold to a linear update statistics threshold.\n This is especially useful to keep statistics updated on large tables. Starting with SQL Server 2016, for databases using compatibility level 130 and above, this behavior is controlled by the engine and trace flag 2371 has no effect.",
      "message": "Disable trace flag 2371 in SQL Server 2016 and higher versions when all databases are at compatibility level 130 and above.",
      "condition": {
        "not": {
          "in": [ 2371, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2389",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Statistics", "Performance" ],
      "displayName": "TF 2389 enables automatic statistics for Ascending Keys",
      "description": "Trace Flag 2389 enables automatically generated quick statistics for ascending keys (histogram amendment).\n This trace flag is recommended to be set in cases where queries access newly inserted ascending key values (such as an IDENTITY column), but the new values are not yet updated in the statistics histogram for the affected columns. In this case the histogram used to estimate cardinality will be adjusted at query compile time.\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 2389 enables automatic statistics for ascending keys. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2801413",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 2389, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2390",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Statistics", "Performance", "Indexes" ],
      "displayName": "TF 2390 enables automatic statistics for Ascending or Unknown Keys",
      "description": "Trace Flag 2390 enables automatically generated quick statistics for ascending or unknown keys (histogram amendment).\n This trace flag is recommended to be set in cases where queries access newly inserted ascending key values (such as an IDENTITY column), but the new values are not yet updated in the statistics histogram for the affected columns. In this case the histogram used to estimate cardinality will be adjusted at query compile time.\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 2390 enables automatic statistics for ascending or unknown keys. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2801413",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": {
          "in": [ 2390, "@TraceFlag" ]
        }
      }
    },
    {
      "id": "TF2528",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "DataIntegrity", "DBCC" ],
      "displayName": "TF 2528 disables parallel operations for integrity checking",
      "description": "Trace Flag 2528 disables parallel checking of objects by DBCC CHECKDB, DBCC CHECKFILEGROUP, and DBCC CHECKTABLE.\n By default, the degree of parallelism is automatically determined by the query processor. The maximum degree of parallelism is configured just like that of parallel queries.\n When parallel checks are disabled, the DBCC commands will take longer to complete.\n Starting with SQL Server 2014 SP2, a MAXDOP option is available to override the max degree of parallelism configuration option of sp_configure for the DBCC statements.",
      "message": "Trace Flag 2528 disables parallel operations for integrity checking.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 2528, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF2549",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "DBCC" ],
      "displayName": "TF 2549 optimizes PHYSICAL_ONLY option of DBCC CHECKDB",
      "description": "Trace Flag 2549 forces the DBCC CHECKDB command to assume each database file is on a unique disk drive but treating different physical files as one logical file.\n This trace flag can improve the performance when using the PHYSICAL_ONLY option, but it's not recommended unless it is known that each file is based on a unique physical disk.",
      "message": "Trace Flag 2549 forces DBCC CHECKDB to treat different physical files as one logical file.",
      "helpLink": "https://support.microsoft.com/help/2634571",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 2549, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF2562",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "DBCC", "TempDB" ],
      "displayName": "TF 2562 forces the DBCC CHECKDB command to execute in a single batch",
      "description": "Trace Flag 2562 forces the DBCC CHECKDB command to execute in a single batch regardless of the number of indexes in the database.\n This trace flag can improve the performance when using the PHYSICAL_ONLY option, but space requirements for TempDB may increase.",
      "message": "Trace Flag 2562 forces the DBCC CHECKDB command to execute in a single batch.",
      "helpLink": "https://support.microsoft.com/help/2634571",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 2562, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF2566",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "DBCC", "DataIntegrity" ],
      "displayName": "TF 2566 disables default data purity check",
      "description": "Trace Flag 2566 forces the DBCC CHECKDB command to execute without data purity check unless the DATA_PURITY option is specified.\n For databases upgraded from earlier versions of SQL Server, it is recommended to run the DBCC CHECKDB WITH DATA_PURITY command at least once, to enable column-value integrity checks to happen by default.",
      "message": "Trace Flag 2566 disables default data purity check.",
      "helpLink": "https://support.microsoft.com/help/945770",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 2566, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF3023",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Backup" ],
      "displayName": "TF 3023 enables Backup Checksum option by default",
      "description": "Trace Flag 3023 enables the CHECKSUM option of the BACKUP command by default.\n This trace flag forces the CHECKSUM option for BACKUP command even when not explicitely set.\n Starting with SQL Server 2014, this behavior is controlled by setting the Backup Checksum Default configuration option.",
      "message": "Trace Flag 3023 enables CHECKSUM option as default for BACKUP command.",
      "helpLink": "https://support.microsoft.com/help/2656988",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 3023, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF3042",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Backup" ],
      "displayName": "TF 3042 bypasses the default backup compression pre-allocation algorithm",
      "description": "Trace Flag 3042 bypasses the default backup compression pre-allocation algorithm to allow the backup file to grow only as needed to reach its final size.\n This trace flag can achieve space savings by allocating only the actual size required for the compressed backup, but might increase the overall backup operation time.",
      "message": "Trace Flag 3042 enables the bypass of the default backup compression.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/backup-restore/backup-compression-sql-server",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 3042, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF3226",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Backup" ],
      "displayName": "TF 3226 disables ErrorLog entries for every successful backup operation",
      "description": "Trace Flag 3226 prevents SQL Server from recording an entry to the Errorlog on every successful backup operation.\n Backup operations are registered in the Errorlog by default. Frequent backup operations can contribute to massive Errorlog files that become unwieldy.",
      "message": "Trace Flag 3226 disables ErrorLog entries for every successful backup operation.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 3226, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF4136",
      "itemType": "override",
      "targetFilter": {
        "version": "[11.0.2316,)"
      },
      "description": "Trace Flag 4136 disables parameter sniffing unless OPTION(RECOMPILE), WITH RECOMPILE or OPTIMIZE FOR value is used. Starting with SQL Server 2016, to accomplish this at the database level use the PARAMETER_SNIFFING option in ALTER DATABASE SCOPED CONFIGURATION. Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 4136 disables parameter sniffing. Verify need to set a non-default trace flag with the current system build and configuration.",
      "level": "Information"
    },
    {
      "id": "TF4136",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag" ],
      "displayName": "TF 4136 disables Parameter Sniffing",
      "description": "Trace Flag 4136 disables parameter sniffing unless OPTION(RECOMPILE), WITH RECOMPILE or OPTIMIZE FOR value is used, but does not apply to this SQL Server version. Starting with SQL Server 2016, to accomplish this at the database level use the PARAMETER_SNIFFING option in ALTER DATABASE SCOPED CONFIGURATION. Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 4136 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/980653",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 4136, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF4137",
      "itemType": "override",
      "targetFilter": {
        "version": "[11.0.2316,)"
      },
      "description": "Trace Flag 4137 causes SQL Server to generate a plan using minimum selectivity when estimating AND predicates for filters to account for partial correlation instead of independence, under the query optimizer cardinality estimation model of SQL Server 2012 and earlier versions (CE 70).\n Does not apply to CE version 120 or above. Use trace flag 9471 instead.\n Starting with SQL Server 2016 SP1, to accomplish this at the query level use the USE HINT 'ASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES' query hint.\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 4137 causes SQL Server to generate a plan using partial correlation of filters. Verify need to set a non-default trace flag with the current system build and configuration.",
      "level": "Information"
    },
    {
      "id": "TF4137",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "displayName": "TF 4137 causes plans to use partial correlation for filters",
      "description": "Trace Flag 4137 causes SQL Server to generate a plan using minimum selectivity when estimating AND predicates for filters to account for partial correlation instead of independence, under the query optimizer cardinality estimation model of SQL Server 2012 and earlier versions (CE 70). However it does not apply to this SQL Server version.\n Does not apply to CE version 120 or above. Use trace flag 9471 instead.\n Starting with SQL Server 2016 SP1, to accomplish this at the query level use the USE HINT 'ASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES' query hint.\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace flag 4137 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2658214",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 4137, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF4138",
      "itemType": "override",
      "targetFilter": {
        "version": "[11.0.2325,)"
      },
      "description": "Trace Flag 4138 causes SQL Server to generate a plan that does not use row goal adjustments with queries that contain TOP, OPTION (FAST N), IN, or EXISTS keywords.\n Starting with SQL Server 2016 SP1, to accomplish this at the query level use the USE HINT 'DISABLE_OPTIMIZER_ROWGOAL' query hint.\n Verify need to set a Non-default trace flag with current system build and configuration.",
      "message": "Trace Flag 4138 enables plan that without row goal adjustments. Verify need to set a non-default trace flag with the current system build and configuration.",
      "level": "Information"
    },
    {
      "id": "TF4138",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "displayName": "TF 4138 causes plans to not use Row Goal adjustments",
      "description": "Trace Flag 4138 causes SQL Server to generate a plan that does not use row goal adjustments with queries that contain TOP, OPTION (FAST N), IN, or EXISTS keywords.\n Starting with SQL Server 2016 SP1, to accomplish this at the query level use the USE HINT 'DISABLE_OPTIMIZER_ROWGOAL' query hint. However it does not apply to this SQL Server version.\n Verify need to set a Non-default trace flag with current system build and configuration.",
      "message": "Trace flag 4138 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2667211",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 4138, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF4139",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[11.0.3431,11.0.5058)",
          "[11.0.5532,)"
        ]
      },
      "description": "Trace Flag 4139 enables automatically generated quick statistics (histogram amendment) regardless of key column status.\n This trace flag is recommended to be set in cases where queries access newly inserted key values that may change plan shape, but the new values are not yet updated in the statistics histogram for the affected columns. In this case, regardless of the leading statistics column status (ascending, descending, or stationary), the histogram used to estimate cardinality will be adjusted at query compile time.\n This trace flag does not apply to the cardinality estimation model of SQL Server 2012 and earlier versions (CE 70).\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace Flag 4139 enables automatic statistics for any key ordering. Verify need to set a non-default trace flag with the current system build and configuration.",
      "level": "Information"
    },
    {
      "id": "TF4139",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Statistics" ],
      "displayName": "TF 4139 enables automatic statistics for any key ordering",
      "description": "Trace Flag 4139 enables automatically generated quick statistics (histogram amendment) regardless of key column status.\n However, this trace flag does not apply to this SQL Server version.\n Verify need to set a non-default trace flag with the current system build and configuration.",
      "message": "Trace flag 4139 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2952101",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 4139, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF4199",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0, 14.0)",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer" ],
      "displayName": "TF 4199 enables Query Optimizer fixes",
      "description": "Trace Flag 4199 enables Query Optimizer fixes released in SQL Server Cumulative Updates and Service Packs.",
      "message": "Trace Flag 4199 enables Query Optimizer fixes. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "http://support.microsoft.com/help/974006",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 4199, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF6498",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[12.0.2474,12.0.2480]",
          "[12.0.4416,12.0.5000)"
        ]
      },
      "message": "Trace Flag 6498 enables concurrent large queries.",
      "level": "Information"
    },
    {
      "id": "TF6498",
      "itemType": "override",
      "targetFilter": {
        "version": "[12.0.5000,)"
      },
      "description": "Trace Flag 6498 enables more than one large query compilation to gain access to the big gateway when there is sufficient memory available.\n This trace flag can be used to keep memory usage for the compilation of incoming queries under control, avoiding compilation waits for concurrent large queries.\n Starting with SQL Server 2014 SP2 and SQL Server 2016, this behavior is controlled by the engine and trace flag 1236 has no effect.",
      "message": "Disable trace flag 6498 in SQL Server 2014 SP2, SQL Server 2016 and higher versions."
    },
    {
      "id": "TF6498",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "Memory" ],
      "displayName": "TF 6498 enables additional concurrent large queries",
      "description": "Trace Flag 6498 enables more than one large query compilation to gain access to the big gateway when there is sufficient memory available.\n However, this trace flag does not apply to this SQL Server version.\n This trace flag can be used to keep memory usage for the compilation of incoming queries under control, avoiding compilation waits for concurrent large queries.\n Starting with SQL Server 2014 SP2 and SQL Server 2016, this behavior is controlled by the engine and trace flag 1236 has no effect.",
      "message": "Trace Flag 6498 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/3024815",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 6498, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF6532",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": [
          "[11.0.6020,11.0.6518)"
        ],
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 6532 enables performance improvements for Spatial data",
      "description": "Trace Flag 6532 enables performance improvements of query operations with spatial data types.\n The performance gain will vary, depending on the configuration, the types of queries, and the objects.",
      "message": "Enable trace flag 6532 to enable performance improvements for Spatial data.",
      "helpLink": "https://support.microsoft.com/help/3107399",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": { "in": [ 6532, "@TraceFlag" ] }
    },
    {
      "id": "TF6532.6533",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[11.0.6518,12.0)",
          "[12.0.5000,13.0)"
        ]
      },
      "description": "Trace Flag 6532 and trace flag 6533 enable performance improvements of query operations with spatial data types.\n The performance gain will vary, depending on the configuration, the types of queries, and the objects.",
      "message": "Enable trace flag 6532 and trace flag 6533 to enable performance improvements for Spatial data.",
      "level": "Information",
      "condition": {
        "and": [
          { "in": [ 6532, "@TraceFlag" ] },
          { "in": [ 6533, "@TraceFlag" ] }
        ]
      }
    },
    {
      "id": "TF6532.6533",
      "itemType": "override",
      "targetFilter": {
        "version": "[13.0,)"
      },
      "message": "Disable trace flag 6532 in SQL Server 2016 and higher versions."
    },
    {
      "id": "TF6532.6533",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 6532 and TF 6533 enable performance improvements for Spatial data",
      "description": "Trace flags 6532 and 6533 enable performance improvements of query operations with spatial data types.\n However, this trace flag does not apply to this SQL Server version.\n Starting with SQL Server 2016, this behavior is controlled by the engine and trace flags 6532 and 6533 have no effect.",
      "message": "Trace flags 6532 and 6533 do not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/3107399",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "and": [
          { "not": { "in": [ 6532, "@TraceFlag" ] } },
          { "not": { "in": [ 6533, "@TraceFlag" ] } }
        ]
      }
    },
    {
      "id": "TF6534",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[11.0.6020,12.0)",
          "[12.0.5000,13.0)"
        ]
      },
      "description": "Trace Flag 6534 enables performance improvements of query operations with spatial data types.\n The performance gain will vary, depending on the configuration, the types of queries, and the objects.",
      "message": "Enable trace flag 6534 to enable performance improvement of query operations with spatial data types.",
      "level": "Information",
      "condition": { "in": [ 6534, "@TraceFlag" ] }
    },
    {
      "id": "TF6534",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 6534 enables performance improvements for Spatial data",
      "description": "Trace Flag 6534 enables performance improvement of query operations with spatial data types.\n However, this trace flag does not apply to this SQL Server version.\n Verify need to set a Non-default trace flag with current system build and configuration.",
      "message": "Trace flag 6534 does not apply to this SQL Server version. Verify need to set a non-default trace flag with the current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/3107399",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 6534, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF7412",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[13.0.4001,15.0)",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 7412 enables the lightweight profiling infrastructure for live query performance troubleshooting",
      "description": "Trace Flag 7412 enables the lightweight profiling infrastructure for live query performance troubleshooting. Consider enabling TF 7412 to have the ability to access runtime information on query execution plans for any session.",
      "message": "Enable trace flag 7412 to enables the lightweight profiling infrastructure for live query performance troubleshooting.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance/query-profiling-infrastructure",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "in": [ 7412, "@TraceFlag" ]
      }
    },
    {
      "id": "TF9024",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "NUMA", "Memory", "CPU" ],
      "displayName": "TF 9024 converts a global log pool memory object into NUMA node partitioned memory object",
      "description": "TF9024 converts a global log pool memory object into NUMA node partitioned memory object.",
      "message": "Verify need to set a Non-default TF with current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2809338/fix-high-log-write-waits-counter-value-on-a-sql-server-2012-or-sql-ser",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 9024, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF9024",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[11.0.3349, 11.0.6020)",
          "[12.0, 12.0.4100)"
        ]
      },
      "message": "Consider enabling TF9024 to convert global log pool memory objects into NUMA node partitioned memory objects.",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags", "ServerInstanceConfiguration" ],
      "condition": [
        { "in": [ 9024, "@TraceFlag" ] },
        {
          "gt": [
            8,
            { "div": [ "@online_logical_processors", "@numa_nodes" ] }
          ]
        }
      ]
    },
    {
      "id": "TF9024",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[11.0.6020, 12.0)",
          "[12.0.4100,)"
        ]
      },
      "message": "TF9024 is not needed in SQL Server 2012 SP3, SQL Server 2014 SP1 and above."
    },
    {
      "id": "TF8048",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "NUMA", "CPU", "Memory" ],
      "displayName": "TF 8048 converts NUMA partitioned memory objects into CPU partitioned",
      "description": "TF 8048 converts NUMA partitioned memory objects into CPU partitioned.",
      "message": "Verify need to set a Non-default TF with current system build and configuration.",
      "helpLink": "https://support.microsoft.com/help/2809338/fix-high-log-write-waits-counter-value-on-a-sql-server-2012-or-sql-ser",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 8048, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF8048",
      "itemType": "override",
      "targetFilter": {
        "version": "[12.0.4100,)"
      },
      "message": "TF8048 is not needed in SQL Server 2014 SP2, SQL Server 2016 and above."
    },
    {
      "id": "TF8048",
      "itemType": "override",
      "targetFilter": {
        "version": "[11.0, 12.0.4100)"
      },
      "message": "Consider enabling TF 8048 to convert NUMA partitioned memory objects into CPU partitioned.",
      "level": "Information",
      "probes": [ "EnabledGlobalTraceFlags", "ServerInstanceConfiguration" ],
      "condition": [
        { "in": [ 8048, "@TraceFlag" ] },
        {
          "gt": [
            8,
            { "div": [ "@online_logical_processors", "@numa_nodes" ] }
          ]
        }
      ]
    },
    {
      "id": "DeprecatedFeatures",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "tempdb", "model", "msdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Deprecated", "Security", "UpdateIssues", "Performance" ],
      "displayName": "Deprecated or discontinued features should not be used",
      "description": "This check detects deprecated or discontinued features used on target SQL Server instance. Deprecated features may be removed in a future release of SQL Server. Discontinued features have been removed from specific versions of SQL Server.",
      "message": "Detected deprecated or discontinued feature uses: @{DeprecatedFeature}. We recommend to replace them with features actual for SQL Server version @{ProductVersion}.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance-monitor/sql-server-deprecated-features-object",
      "probes": [ "DeprecatedFeaturesStats", "SQLServerVersion" ],
      "condition": {
        "equal": [ "@DeprecatedFeature", "" ]
      }
    },
    {
      "id": "SystemHealthSession",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "XEvent", "SystemHealth" ],
      "displayName": "system_health XEvent session is not active",
      "description": "This session starts automatically when the SQL Server Database Engine starts, and runs without any noticeable performance effects. The session collects system data that you can use to help troubleshoot performance issues in the Database Engine.\n We recommend that you do not stop, alter, or delete the system health session.",
      "message": "Start the session by using the ALTER EVENT SESSION statement or by using the Extended Events node in Object Explorer.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/extended-events/use-the-system-health-session",
      "level": "Warning",
      "probes": [ "XEvent.SystemHealth" ],
      "condition": "@XEvent.SystemHealthCount"
    },
    {
      "id": "SPServerDiagnosticsSession",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "XEvent", "SystemHealth" ],
      "displayName": "sp_server_diagnostics xEvent session is not active",
      "description": "This session starts automatically when the SQL Server Database Engine starts, and runs without any noticeable performance effects. The session collects system data that you can use to help troubleshoot performance issues in the Database Engine.\n We recommend that you do not stop, alter, or delete the system health session.",
      "message": "Start the session by using the ALTER EVENT SESSION statement or by using the Extended Events node in Object Explorer.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/system-stored-procedures/sp-server-diagnostics-transact-sql",
      "level": "Warning",
      "probes": [ "XEvent.SPServerDiagnostics" ],
      "condition": "@XEvent.SPServerDiagnostics"
    },
    {
      "id": "BlackboxTrace",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Traces" ],
      "displayName": "Blackbox trace is configured and running",
      "description": "This trace is designed to behave similarly to an airplane black box, to help you diagnose intermittent server crashes. It consumes more resources than the default trace and should not be running for extended periods of time.",
      "message": "Make sure you still need the blackbox trace and stop it otherwise.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/system-stored-procedures/sp-trace-create-transact-sql",
      "level": "Warning",
      "probes": [ "CountBlackBoxTraces" ],
      "condition": { "not": "@BlackBoxTraceCount" }
    },
    {
      "id": "DefaultTrace",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Traces" ],
      "displayName": "No default trace was found or is not active",
      "description": "Default trace provides troubleshooting assistance to database administrators by ensuring that they have the log data necessary to diagnose problems the first time they occur.",
      "message": "Make sure that there is enough space for SQL Server to write the default trace file. Then have the default trace run by disabling and re-enabling it.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/policy-based-management/default-trace-log-files-disabled",
      "level": "Warning",
      "probes": [ "CountDefaultTraces" ],
      "condition": "@DefaultTraceCount"
    },
    {
      "id": "HintsStatistics",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "QueryOptimizer", "Performance", "Statistics" ],
      "displayName": "Hints are being used",
      "description": "Hints are options or strategies specified for enforcement by the SQL Server query processor on SELECT, INSERT, UPDATE, or DELETE statements. The hints override any execution plan the Query Optimizer might select for a query. Because the SQL Server Query Optimizer typically selects the best execution plan for a query, we recommend that <join_hint>, <query_hint>, and <table_hint> be used only as a last resort by experienced developers and database administrators.",
      "message": "We recommend that <join_hint>, <query_hint>, and <table_hint> be used only as a last resort by experienced developers and database administrators, because the SQL Server Query Optimizer typically selects the best execution plan for a query.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql",
      "level": "Information",
      "probes": [ "Hints.InstanceStatistics" ],
      "condition": { "@HintUsageCount": 0 }
    },
    {
      "id": "HintsUsageInModules",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "QueryOptimizer", "Performance", "Statistics" ],
      "displayName": "Hints usage in modules",
      "enabled": false,
      "description": "Hints are options or strategies specified for enforcement by the SQL Server query processor on SELECT, INSERT, UPDATE, or DELETE statements. The hints override any execution plan the Query Optimizer might select for a query. Because the SQL Server Query Optimizer typically selects the best execution plan for a query, we recommend that <join_hint>, <query_hint>, and <table_hint> be used only as a last resort by experienced developers and database administrators.",
      "message": "@{Hint} was used in @{type_desc} @{Schema_Name}.@{Object_Name}.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql",
      "level": "Information",
      "probes": [ "Hints.ModuleUsage" ]
    },
    {
      "id": "PlansUseRatio",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "QueryOptimizer" ],
      "displayName": "Amount of single use plans in cache is high",
      "description": "Single use plans waste system resources.",
      "message": "Amount of single use plans in cache is high (@{SingleUsePlansUseRatio:P0}). Consider enabling the Optimize for ad hoc workloads setting on heavy OLTP ad-hoc workloads to conserve resources.",
      "helpLink": "https://docs.microsoft.com/sql/database-engine/configure-windows/optimize-for-ad-hoc-workloads-server-configuration-option",
      "level": "Warning",
      "probes": [ "CachedPlans.SingleUseRatio" ],
      "condition": { "less": [ "@SingleUsePlansUseRatio", 0.5 ] }
    },
    {
      "id": "HypotheticalIndexes",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Hypothetical indexes found",
      "description": "Database has indexes that are marked as hypothetical. Hypothetical indexes are created by the Database Tuning Assistant (DTA) during its tests. If a DTA session was interrupted, these indexes may not be deleted. It is recommended to drop these objects as soon as possible.",
      "message": "Index @{IndexName} for @{Schema}.@{Object} is marked as hypothetical. It is recommended to drop hypothetical index @{IndexName} as soon as possible.",
      "helpLink": "https://blogs.technet.microsoft.com/anurag_sharma/2008/04/15/hypothetical-indexes",
      "level": "Warning",
      "probes": [ "Hypothetical.Indexes" ]
    },
    {
      "id": "HypotheticalStatistics",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Statistics" ],
      "displayName": "Hypothetical statistics found",
      "description": "Database has statistics that are marked as hypothetical. Hypothetical statistics are created by the Database Tuning Assistant (DTA) during its tests. If a DTA session was interrupted, these statistics may not be deleted. It is recommended to drop these objects as soon as possible.",
      "message": "Statistics @{StatName} for @{Schema}.@{Object} is hypothetical. It is recommended to drop hypothetical statistics @{StatName} as soon as possible.",
      "helpLink": "https://blogs.technet.microsoft.com/anurag_sharma/2008/04/15/hypothetical-indexes",
      "level": "Warning",
      "probes": [ "Hypothetical.Statistics" ]
    },
    {
      "id": "LatestCU",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Security", "UpdateIssues" ],
      "displayName": "SQL Server instance is not up to date",
      "description": "On an installed instance of SQL Server, we recommend that you apply the latest security updates and critical updates including general distribution releases (GDRs), service packs (SPs), and cumulative updates (CUs).",
      "message": "Product version @{ProductVersion} is not the latest available. We recommend keeping your SQL Server up to date and install Service Packs and Cumulative Updates as they are released.",
      "helpLink": "https://support.microsoft.com/help/321185/how-to-determine-the-version-edition-and-update-level-of-sql-server-an",
      "probes": [ "SQLServerVersion" ]
    },
    {
      "id": "LatestCU",
      "itemType": "override",
      "targetFilter": {
        "version": [
          "[11.0.7001, 12.0)",
          "[12.0.6329, 13.0)",
          "[13.0.5492, 14.0)",
          "[14.0.3238, 15.0)",
          "[15.0.2070,)"
        ]
      },
      "displayName": "SQL Server instance is up to date",
      "message": "Product version @{ProductVersion} is the latest available.",
      "helpLink": "https://support.microsoft.com/help/321185/how-to-determine-the-version-edition-and-update-level-of-sql-server-an",
      "condition": true
    },
    {
      "id": "FKNoIndexes",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "engineEdition": "OnPremises, ManagedInstance",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Indexes" ],
      "displayName": "Foreign key constraints should have corresponding indexes",
      "description": "Unlike primary key constraints, creating a foreign key constraint does not automatically create a corresponding index. However, manually creating an index on a foreign key is often useful.",
      "message": "Create a corresponding index for each foreign key. There is no index on the following foreign keys: @{ConstraintName}.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/tables/primary-and-foreign-key-constraints",
      "level": "Warning",
      "probes": [ "FKNoIndexes" ],
      "condition": { "@ConstraintName": "" }
    },
    {
      "id": "MissedIndexes",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Indexes" ],
      "displayName": "Potentially missing indexes",
      "description": "Potentially missing indexes were found based on query history. It may be important to revise them.",
      "message": "Create an index on @{Table} with key columns @{KeyCols}@{IncludedCols: and included columns: #}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/sql-server-index-design-guide",
      "level": "Information",
      "probes": [ "MissedIndexes" ]
    },
    {
      "id": "FullBackup",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "name": { "not": ["model", "tempdb"] },
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Backup" ],
      "displayName": "Full backup is missed or outdated",
      "description": "Database doesn't have any full backup or the latest full backup is over 7 days.",
      "message": "The last full backup had been created more than @{threshold} days ago. Create a new full backup.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/backup-restore/create-a-full-database-backup-sql-server",
      "level": "Warning",
      "probes": [ "DatabaseBackups" ],
      "condition": {
        "not": { "equal": [ "@LastFullBackup", null ] },
        "less": [
          "@LastFullBackup",
          { "mul": ["@threshold", 24] }
        ]
      },
      "threshold": 7
    },
    {
      "id": "OutdatedTranLogBackup",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Backup" ],
      "displayName": "Transaction Log backup is missed or outdated",
      "description": "Database does not have any transaction Log backup since the latest full or differential backup, or it's older than 24H.",
      "message": "Create a backup of Transaction Log. Database recovery model: @{recovery_model_desc}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/backup-restore/back-up-a-transaction-log-sql-server",
      "level": "Warning",
      "probes": [ "DatabaseBackups" ],
      "condition": {
        "not": { "equal": [ "@LastTLBackup", null ] },
        "less": [ "@recovery_model", 3 ],
        "less": [ "@LastTLBackup", 24 ]
      }
    },
    {
      "id": "DbDiffCollation",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "Collation" ],
      "displayName": "Database collation doesn't match the collation of master",
      "description": "We recommend that the collations of user-defined databases match the collation of master or model. Otherwise, collation conflicts can occur that might prevent code from executing. For example, when a stored procedure joins one table to a temporary table, SQL Server might end the batch and return a collation conflict error if the collations of the user-defined database and the model database are different. This occurs because temporary tables are created in tempdb, which bases its collation on that of model.",
      "message": "Keep database collation the same as the collation for master or model",
      "helpLink": "https://docs.microsoft.com/sql/database-engine/set-collation-user-defined-databases-match-master-model-databases",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": {
        "equal": [ "@collation_name", "@master_collation" ]
      }
    },

    {
      "id": "AutoClose",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "name": { "not": ["master", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "DBConfiguration" ],
      "displayName": "Auto Close Option should be OFF",
      "description": "When AUTO_CLOSE is set ON, this can cause performance degradation on frequently accessed databases because of the increased overhead of opening and closing the database after each connection. AUTO_CLOSE also flushes the procedure cache after each connection.",
      "message": "Set AUTO_CLOSE option to OFF",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/policy-based-management/set-the-auto-close-database-option-to-off",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": { "not": "@is_auto_close_on" }
    },

    {
      "id": "AutoShrink",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "Performance" ],
      "displayName": "Auto Shrink Option should be OFF",
      "description": "Shrinking databases is the fastest way to achieve fragmentation. SQL Server goes to the last page in the database, moves it to the first free available space, and then repeats the process again. This shuffles the deck, putting your pages out of order.",
      "message": "Set AUTO_SHRINK option to OFF",
      "helpLink": "https://blogs.msdn.microsoft.com/buckwoody/2009/07/01/sql-server-best-practices-auto-shrink-should-be-off",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": { "not": "@is_auto_shrink_on" }
    },

    {
      "id": "PageVerify",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "name": { "not": ["master", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "DataIntegrity" ],
      "displayName": "PAGE_VERIFY option should be CHECKSUM",
      "description": "When CHECKSUM is enabled for the PAGE_VERIFY database option, the SQL Server Database Engine calculates a checksum over the contents of the whole page, and stores the value in the page header when a page is written to disk. When the page is read from disk, the checksum is recomputed and compared to the checksum value that is stored in the page header. This helps provide a high level of data-file integrity.",
      "message": "Set PAGE_VERIFY option to CHECKSUM",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/policy-based-management/set-the-page-verify-database-option-to-checksum",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": { "@page_verify_option": 2 }
    },

    {
      "id": "DbChaining",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "Security" ],
      "displayName": "Cross-Database Access should be disabled",
      "description": "Ownership chaining across databases is turned off by default. Microsoft recommends that you disable cross-database ownership chaining because it exposes you to the additional security risks.",
      "message": "Set DB_CHAINING option to OFF",
      "helpLink": "https://docs.microsoft.com/dotnet/framework/data/adonet/sql/enabling-cross-database-access-in-sql-server",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": { "not": "@is_db_chaining_on" }
    },

    {
      "id": "AutoCreateStatsIncremental",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[12.0,)",
        "name": { "not": ["master", "msdb", "tempdb"] }
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "Statistics", "Performance" ],
      "displayName": "Incremental option of auto stats should be ON",
      "description": "Incremental statistics update at partition level is a feature introduced in SQL Server 2014. When the option INCREMENTAL is turn on at the database level, newly auto created column statistics will use incremental statistics on partitioned tables by default.",
      "message": "Set AUTO_CREATE_STATISTICS to ON and set INCREMENTAL to ON",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/statistics/statistics",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": "@is_auto_create_stats_incremental_on"
    },

    {
      "id": "TrustWorthy",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "name": { "not": ["master", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "Security" ],
      "displayName": "TRUSTWORTHY should be OFF",
      "description": "You can use the TRUSTWORTHY database setting to indicate whether the instance of Microsoft SQL Server trusts the database and the contents within the database. By default, this setting is set to OFF to mitigate certain threats that may be present when a database is attached to the server.",
      "message": "Set TRUSTWORTHY option to OFF",
      "helpLink": "https://support.microsoft.com/help/2183687/guidelines-for-using-the-trustworthy-database-setting-in-sql-server",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": { "not": "@is_trustworthy_on" }
    },

    {
      "id": "ParameterizationNotSimple",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBConfiguration", "Performance", "QueryOptimizer" ],
      "displayName": "PARAMETERIZATION should be SIMPLE",
      "description": "When the PARAMETERIZATION database option is set to SIMPLE, the SQL Server query optimizer may choose to parameterize the queries. This means that any literal values that are contained in a query are substituted with parameters. This process is referred to as simple parameterization. When SIMPLE parameterization is in effect, you cannot control which queries are parameterized and which queries are not. However, you can specify that all queries in a database be parameterized by setting the PARAMETERIZATION database option to FORCED. Regardless of whether you have a Plan-Stability or not, SQL Server will always auto parameterize your SQL Statements, and reuse the cached execution plan over and over again. It doesn't matter how terrible the execution plan is. Therefore you have to know in exact detail the shape of your execution plans, and whether they can lead to some performance related problems.",
      "message": "Set PARAMETERIZATION = SIMPLE and use forced parameterization only on a certain class of queries, instead of all queries",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance/specify-query-parameterization-behavior-by-using-plan-guides",
      "level": "Warning",
      "probes": [ "DatabaseConfiguration" ],
      "condition": { "not": "@is_parameterization_forced" }
    },

    {
      "id": "TempDBFilesNotSameSize",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TempDB", "Performance", "DBFileConfiguration" ],
      "displayName": "TempDB data files are not the same size",
      "description": "We recommend that you create all TempDB data files at the same size.",
      "message": "Make all TempDB data files the same size",
      "helpLink": "https://support.microsoft.com/kb/2154845",
      "level": "Warning",
      "probes": [ "TempDBFiles" ],
      "condition": { "@filesizeCount": 1 }
    },

    {
      "id": "TempDBFilesMultiple4",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TempDB", "Performance", "DBFileConfiguration" ],
      "displayName": "Number of TempDB data files should be in multiples of 4",
      "description": "Number of TempDB data files should correlate with the number of (logical) processors on the machine. As a general rule, if the number of logical processors is less than or equal to 8, use the same number of data files as logical processors. If the number of logical processors is greater than 8, use 8 data files and then if contention continues, increase the number of data files by multiples of 4 until the contention is reduced to acceptable levels or make changes to the workload/code.",
      "message": "Make sure number of TempDB data files is in multiples of 4",
      "helpLink": "https://support.microsoft.com/kb/2154845",
      "level": "Warning",
      "probes": [
        {
          "id": "DatabaseMasterFiles",
          "params": {
            "dbId": 2,
            "type": 0
          },
          "transform": {
            "type": "aggregate",
            "map": {
              "physical_name": "count"
            }
          }
        },
        "ServerInstanceConfiguration"
      ],
      "condition": [
        { "less": [ "@online_logical_processors", 8 ] },
        {
          "equal": [
            { "mod": [ "@physical_name", 4 ] },
            0
          ]
        }
      ]
    },

    {
      "id": "TempDBFiles1PerCPU",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TempDB", "Performance", "DBFileConfiguration" ],
      "displayName": "Number of TempDB data files should depend on CPU count",
      "description": "Number of TempDB data files should correlate with the number of (logical) processors on the machine. As a general rule, if the number of logical processors is less than or equal to 8, use the same number of data files as logical processors. If the number of logical processors is greater than 8, use 8 data files and then if contention continues, increase the number of data files by multiples of 4 until the contention is reduced to acceptable levels or make changes to the workload/code.",
      "message": "Make sure to have 1 data file per logical processor (processors count: @{online_logical_processors})",
      "helpLink": "https://support.microsoft.com/kb/2154845",
      "level": "Warning",
      "probes": [
        {
          "id": "DatabaseMasterFiles",
          "params": {
            "dbId": 2,
            "type": 0
          },
          "transform": {
            "type": "aggregate",
            "map": {
              "physical_name": "count"
            }
          }
        },
        "ServerInstanceConfiguration"
      ],
      "condition": [
        { "greater": [ "@online_logical_processors", 8 ] },
        { "greaterequal": [ "@physical_name", "@online_logical_processors" ] }
      ]
    },

    {
      "id": "TempDBFilesNotLess8",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TempDB", "Performance", "DBFileConfiguration" ],
      "displayName": "Number of TempDB data files should be at least 8",
      "description": "Number of TempDB data files should correlate with the number of (logical) processors on the machine. As a general rule, if the number of logical processors is less than or equal to 8, use the same number of data files as logical processors. If the number of logical processors is greater than 8, use 8 data files and then if contention continues, increase the number of data files by multiples of 4 until the contention is reduced to acceptable levels or make changes to the workload/code.",
      "message": "Add extra data files to TempDB. There are @{physical_name} data files, should be at least 8",
      "helpLink": "https://support.microsoft.com/kb/2154845",
      "level": "Warning",
      "probes": [
        {
          "id": "DatabaseMasterFiles",
          "params": {
            "dbId": 2,
            "type": 0
          },
          "transform": {
            "type": "aggregate",
            "map": {
              "physical_name": "count"
            }
          }
        },
        "ServerInstanceConfiguration"
      ],
      "condition": [
        { "less": [ "@online_logical_processors", 9 ] },
        { "greater": [ "@physical_name", 7 ] }
      ]
    },

    {
      "id": "TempDBFilesAutoGrowth",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "TempDB", "Performance", "DBFileConfiguration" ],
      "displayName": "TempDB data files have different auto growth settings",
      "description": "TempDB data files should be of equal size within each filegroup, as SQL Server uses a proportional-fill algorithm that favors allocations in files with more free space.",
      "message": "Make Autogrowth settings the same for each TempDB data file",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/databases/tempdb-database",
      "level": "Warning",
      "probes": [
        {
          "id": "DatabaseMasterFiles",
          "params": {
            "dbId": 2,
            "type": 0
          },
          "transform": {
            "type": "aggregate",
            "map": {
              "growth": "count",
              "is_percent_growth": "count"
            }
          }
        }
      ],
      "condition": {
        "and": [
          { "@growth": 1 },
          { "@is_percent_growth": 1 }
        ]
      }
    },

    {
      "id": "FilesAutogrowth",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "version": "[13.0.4001,)",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance"
      },
      "tags": [ "DefaultRuleset", "Performance", "DBFileConfiguration" ],
      "displayName": "Database files have Autogrowth setting over 1GB",
      "description": "A data or log file will be extended with auto-growth value to prevent the lack of free space in files. This process can perform significant impact on SQL Server performance if auto-growth value gets over 1 GB. By default, SQL Server will put zeros to a newly allocated space. And the more space it takes, the more time it takes to initialize it.",
      "message": "Set File Growth to less than 1GB for files: @{FileName}",
      "helpLink": "https://support.microsoft.com/help/315512/considerations-for-the-autogrow-and-autoshrink-settings-in-sql-server",
      "level": "Warning",
      "probes": [ "Autogrow1GB" ],
      "condition": { "@FileName": "" }
    },

    {
      "id": "DuplicateIndexes",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Indexes" ],
      "displayName": "There are tables with duplicate indexes",
      "description": "There are tables with duplicate indexes according to their definitions. We recommended to revise all these objects as soon as possible.",
      "message": "Consider removing duplicate indexes in table @{Table}: @{ToDelete}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/sql-server-index-design-guide",
      "level": "Warning",
      "probes": [
        {
          "id": "IndexesDefinitions",
          "transform": {
            "type": "duplicateIndexes"
          }
        }
      ]
    },

    {
      "id": "RedundantIndexes",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Indexes" ],
      "displayName": "There are tables with possibly redundant indexes",
      "description": "There are tables with possibly redundant indexes according to the set of key and included columns. We recommended to revise all these objects as soon as possible.",
      "message": "Consider removing redundant indexes in table @{Table}: @{Indexes}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/sql-server-index-design-guide",
      "level": "Warning",
      "probes": [
        {
          "id": "IndexesDefinitions",
          "transform": {
            "type": "redundantIndexes"
          }
        }
      ]
    },
    {
      "id": "UserObjectsInMaster",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": "master",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "masterDB", "Backup" ],
      "displayName": "User objects in database master",
      "description": "We highly recommend you not create user objects in the master database. If it's unavoidable for some reason, make sure to back up the database more frequently.",
      "message": "Remove user objects from database master: @{Object_Name}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/databases/master-database",
      "probes": [ "UserObjectsCountInMasterDB" ],
      "condition": {
        "@Object_Name": ""
      }
    },

    {
      "id": "HighCPUUsage",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "CPU" ],
      "displayName": "High CPU usage on server",
      "description": "Keeping CPU usage rates within normal ranges is vital for servers hosting SQL Server instances. A continually high rate of CPU usage may indicate the need to upgrade the CPU or add multiple processors. Alternatively, a high CPU usage rate may indicate a poorly tuned or designed application. Optimizing the application can lower CPU utilization.",
      "message": "Investigate high CPU utilization on server hosting this instance. Last 2 hours: total CPU usage is ~@{AVGTotalCPUUsage}%, usage by SQL Server is ~@{AVGSQLCPUUsage}%",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance-monitor/monitor-cpu-usage",
      "level": "Warning",
      "probes": [ "CpuUsage" ],
      "threshold": 70,
      "condition": {
        "less": [ "@AVGTotalCPUUsage", "@threshold" ]
      }
    },

    {
      "id": "ReplErrors24H",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Replication" ],
      "displayName": "Replication errors in the last 24 hours",
      "description": "This check searches for errors in distribution database agent's history table for the last 24 hours.",
      "message": "Review replication errors for the following publications: @{publication}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/replication/sql-server-replication",
      "level": "Warning",
      "probes": [ "ReplicationErrors" ],
      "condition": { "@publication": "" }
    },

    {
      "id": "AgentAlertsSeverity10",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 10",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 825, 833, 855, 856, 3452, 3619, 17179, 17883, 17884, 17887, 17888, 17890, 28036 ],
      "severityN": 10
    },

    {
      "id": "AgentAlertsSeverity16",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 16",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 2508, 2511, 3271, 5228, 5229, 5242, 5243, 5250, 5901, 17130, 17300 ],
      "severityN": 16
    },

    {
      "id": "AgentAlertsSeverity17",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 17",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 802, 845, 1101, 1105, 1121, 1214, 8642, 9002 ],
      "severityN": 17
    },

    {
      "id": "AgentAlertsSeverity19",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 19",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 701 ],
      "severityN": 19
    },

    {
      "id": "AgentAlertsSeverity20",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 20",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 3624 ],
      "severityN": 20
    },

    {
      "id": "AgentAlertsSeverity21",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 21",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 605 ],
      "severityN": 21
    },

    {
      "id": "AgentAlertsSeverity22",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 22",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 5180, 8966 ],
      "severityN": 22
    },

    {
      "id": "AgentAlertsSeverity23",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 23",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 5572, 9100 ],
      "severityN": 23
    },

    {
      "id": "AgentAlertsSeverity24",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Agent" ],
      "displayName": "Agent doesn't rise alerts for errors with severity 24",
      "description": "Events are generated by SQL Server and entered into the Microsoft Windows application log. SQL Server Agent reads the application log and compares events written there to alerts that you have defined. When SQL Server Agent finds a match, it fires an alert, which is an automated response to an event. In addition to monitoring SQL Server events, SQL Server Agent can also monitor performance conditions and Windows Management Instrumentation (WMI) events.",
      "message": "Consider creating alerts for the following errors: @{error_ids}",
      "helpLink": "https://docs.microsoft.com/sql/ssms/agent/alerts",
      "level": "Warning",
      "probes": [ "SysAlerts" ],
      "condition": [
        { "in": [ "@severityN", "@severity" ] },
        { "intersect": [ "@error_ids", "@message_id" ] }
      ],
      "error_ids": [ 823, 824, 832 ],
      "severityN": 24
    },

    {
      "id": "WeakPassword",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Security", "WeakPassword" ],
      "displayName": "Weak password",
      "description": "Some user logins have weak passwords.",
      "message": "Make sure to set strong passwords on the following logins: @{PasswordData}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/security/strong-passwords",
      "probes": [ "WeakPassword" ]
    },
    {
      "id": "VLFCount",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Backup", "Performance" ],
      "displayName": "VLF count",
      "description": "The SQL Server Database Engine divides each physical log file internally into a number of virtual log files (VLFs). Virtual log files have no fixed size, and there is no fixed number of virtual log files for a physical log file. The Database Engine chooses the size of the virtual log files dynamically while it is creating or extending log files. The Database Engine tries to maintain a small number of virtual files. The size of the virtual files after a log file has been extended is the sum of the size of the existing log and the size of the new file increment. The size or number of virtual log files cannot be configured or set by administrators. If the log files grow to a large size in many small increments, they will have many virtual log files. This can slow down database startup and also log backup and restore operations. Conversely, if the log files are set to a large size with few or just one increment, they will have few very large virtual log files. We recommend that you assign log files a size value close to the final size required, using the required increments to achieve optimal VLF distribution, and also have a relatively large growth_increment value.",
      "message": "Update transaction log settings to reduce the number of VLFs (current number is: @{RecoveryUnitId})",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/sql-server-transaction-log-architecture-and-management-guide",
      "probes": [
        {
          "id": "VLF",
          "transform": {
            "type": "aggregate",
            "map": {
              "RecoveryUnitId": {
                "type": "count",
                "distinct": false
              }
            }
          }
        }
      ],
      "condition": {
        "less": [ "@RecoveryUnitId", "@threshold" ]
      },
      "threshold": 50
    },
    {
      "id": "TF8015",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,11.0.3349)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "CPU", "NUMA" ],
      "displayName": "TF 8015 disables auto-detection and NUMA setup",
      "description": "SQL Server allows you to group CPUs into nodes referred to as soft-NUMA. You usually configure soft-NUMA when you have many CPUs and do not have hardware NUMA, but you can also use soft-NUMA to subdivide hardware NUMA nodes into smaller groups.",
      "message": "Disable trace flag 8015 for this SQL Server instance. This TF does not apply to this SQL Server version",
      "helpLink": "https://techcommunity.microsoft.com/t5/SQL-Server-Support/How-It-Works-Soft-NUMA-I-O-Completion-Thread-Lazy-Writer-Workers/ba-p/316044",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 8015, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF8032",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 8032 reverts the cache limit parameters to the SQL Server 2005 RTM",
      "description": "Trace Flag 8032 reverts the cache limit parameters to the SQL Server 2005 RTM setting but can cause poor performance if large caches make less memory available for other memory consumers like BP.",
      "message": "The cache limit parameters reverted to the SQL Server 2005 RTM setting but can cause poor performance if large caches make less memory available for other memory consumers like BP",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 8032, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF8744",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,12.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 8744 disables pre-fetching for the Nested Loop operator",
      "description": "Trace flag 8744 disables pre-fetching for the Nested Loops operator. Incorrect use of this trace flag may cause additional physical reads when SQL Server executes plans that contain the Nested Loops operator.",
      "message": "Disable trace flag 8744 for this SQL Server instance. This TF does not apply to this SQL Server version",
      "helpLink": "https://support.microsoft.com/help/920093/tuning-options-for-sql-server-when-running-in-high-performance-workloa",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 8744, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF9347",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,13.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 9347 disables batch mode for sort operator",
      "description": "Trace flag 9347 disables batch mode for sort operator. SQL Server 2016 (13.x) introduced a new batch mode sort operator that boosts performance for many analytical queries.",
      "message": "Disable trace flag 9347 for this SQL Server instance. This TF does not apply to this SQL Server version",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 9347, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF9349",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,13.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance" ],
      "displayName": "TF 9349 disables batch mode for top N sort operator",
      "description": "Trace flag 9349 disables batch mode for top N sort operator. SQL Server 2016 (13.x) introduced a new batch mode top sort operator that boosts performance for many analytical queries.",
      "message": "Disable trace flag 9349 for this SQL Server instance. This TF does not apply to this SQL Server version",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 9349, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF9389",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,13.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises, ManagedInstance"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "TempDB" ],
      "displayName": "TF 9389 enables dynamic memory grant for batch mode operators",
      "description": "Trace flag 9389 enables additional dynamic memory grant for batch mode operators. If a query does not get all the memory it needs, it spills data to TempDB, incurring additional I/O and potentially impacting query performance. If the dynamic memory grant trace flag is enabled, a batch mode operator may ask for additional memory and avoid spilling to TempDB if additional memory is available.",
      "message": "Disable trace flag 9389 for this SQL Server instance. The TF does not apply to this SQL Server version",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 9389, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF9476",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,13.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "QueryOptimizer" ],
      "displayName": "TF 9476 causes SQL Server to generate a plan using Simple Containment assumption",
      "description": "Trace flag 9476 causes SQL Server to generate a plan using the Simple Containment assumption instead of the default Base Containment assumption, under the query optimizer cardinality estimation model of SQL Server 2014 (12.x) through SQL Server 2017 versions.",
      "message": "Disable trace flag 9476 for this SQL Server instance. The TF does not apply to this SQL Server version",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 9476, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF9481",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,12.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "QueryOptimizer", "Performance" ],
      "displayName": "TF 9481 enables Legacy CE model, irrespective of the compatibility level of the database",
      "description": "Trace flag 9481 enables you to set the query optimizer cardinality estimation model to the SQL Server 2012 (11.x) and earlier versions, irrespective of the compatibility level of the database.",
      "message": "Disable trace flag 9481 for this SQL Server instance. The TF does not apply to this SQL Server version",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 9481, "@TraceFlag" ] }
      }
    },
    {
      "id": "TF10204",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "version": "[11.0,13.0)",
        "platform": "Windows",
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "ColumnStore" ],
      "displayName": "TF 10204 disables merge/recompress during columnstore index reorganization",
      "description": "Trace flag 10204 disables merge/recompress during columnstore index reorganization. In SQL Server 2016 (13.x), when a columnstore index is reorganized, there is new functionality to automatically merge any small compressed rowgroups into larger compressed rowgroups, as well as recompressing any rowgroups that have a large number of deleted rows.",
      "message": "Disable trace flag 10204 for this SQL Server instance. The TF does not apply to this SQL Server version",
      "probes": [ "EnabledGlobalTraceFlags" ],
      "condition": {
        "not": { "in": [ 10204, "@TraceFlag" ] }
      }
    },
    {
      "id": "SPNaming",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "level": "Warning",
      "tags": [ "DefaultRuleset", "Naming" ],
      "displayName": "Stored Procedure Naming",
      "description": "In SQL Server, the sp_ prefix designates system stored procedures. If you use that prefix for your stored procedures, the name of your procedure might conflict with the name of a system stored procedure that will be created in the future. If such a conflict occurs, your application might break if your application refers to the procedure without qualifying the reference by schema. In this situation, the name will bind to the system procedure instead of to your procedure.",
      "message": "Rename the following stored procedures to get rid of the sp_ prefix: @{ObjectName}",
      "helpLink": "https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/dd172115(v=vs.100)",
      "probes": [ "BadNamingSP" ],
      "condition": { "not": "@ObjectName" }
    },
    {
      "id": "ObjectNamingSpecialChar",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "level": "Warning",
      "tags": [ "DefaultRuleset", "Naming" ],
      "displayName": "Object Naming",
      "description": "If you name a database object by using any character in the following table, you make it more difficult not only to reference that object but also to read code that contains the name of that object.",
      "message": "Rename the following objects to get rid of special characters: @{ObjectName}",
      "helpLink": "https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/dd172134(v=vs.100)",
      "probes": [ "BadNamingSpecialChars" ],
      "condition": { "not": "@ObjectName" }
    },
    {
      "id": "ColumnNamingSpecialChar",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "level": "Warning",
      "tags": [ "DefaultRuleset", "Naming" ],
      "displayName": "Column Naming",
      "description": "If you name a database object by using any character in the following table, you make it more difficult not only to reference that object but also to read code that contains the name of that object.",
      "message": "Rename the following columns to get rid of special characters: @{ObjectName}",
      "helpLink": "https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/dd172134(v=vs.100)",
      "probes": [ "BadNamingSpecialCharsColumns" ],
      "condition": { "not": "@ObjectName" }
    },
    {
      "id": "FnNaming",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "level": "Warning",
      "tags": [ "DefaultRuleset", "Naming" ],
      "displayName": "User Function Naming",
      "description": "In SQL Server, the fn_ prefix designates system functions. If you use that prefix for your functions, the name of your function might conflict with the name of a system function that will be created in the future. If such a conflict occurs, your application might break if your application refers to the function without qualifying the reference by schema. In this situation, the name will bind to the system function instead of to your function.",
      "message": "Rename the following functions to get rid of the fn_ prefix: @{ObjectName}",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/create-function-transact-sql",
      "probes": [ "BadNamingUserFunctions" ],
      "condition": { "not": "@ObjectName" }
    },
    {
      "id": "ObjectNamingResKeywords",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "level": "Warning",
      "tags": [ "DefaultRuleset", "Naming" ],
      "displayName": "Object names contain reserved keywords",
      "description": "Microsoft SQL Server uses reserved keywords for defining, manipulating, and accessing databases. Reserved keywords are part of the grammar of the Transact-SQL language that is used by SQL Server to parse and understand Transact-SQL statements and batches. Although it is syntactically possible to use SQL Server reserved keywords as identifiers and object names in Transact-SQL scripts, you can do this only by using delimited identifiers.",
      "message": "Rename the following objects to get rid of reserved keywords: @{ObjectName}",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/language-elements/reserved-keywords-transact-sql",
      "probes": [ "BadNamingKeywords" ],
      "condition": { "not": "@ObjectName" }
    },
    {
      "id": "DeprFeaturesInModules",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "tempdb", "model", "msdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Security", "Deprecated", "LongRunningChecks", "UpdateIssues" ],
      "displayName": "Use of deprecated or discontinued features in modules",
      "description": "Deprecated features are scheduled to be removed in a future release of SQL Server. Discontinued features have been removed from specific versions of SQL Server.",
      "message": "Consider getting rid of the following deprecated or discontinued features in @{ObjectName}: @{Keyword}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance-monitor/sql-server-deprecated-features-object",
      "level": "Warning",
      "probes": [ "DeprecatedFeaturesSQLModules" ]
    },
    {
      "id": "DeprFeaturesInJobs",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Security", "Deprecated", "Agent", "Jobs", "LongRunningChecks", "UpdateIssues" ],
      "displayName": "Use of deprecated or discontinued features in modules",
      "description": "Deprecated features are scheduled to be removed in a future release of SQL Server. Discontinued features have been removed from specific versions of SQL Server.",
      "message": "Consider getting rid of the following deprecated or discontinued features in job @{ObjectName}: @{Keyword}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/performance-monitor/sql-server-deprecated-features-object",
      "level": "Warning",
      "probes": [ "DeprecatedFeaturesJobs" ]
    },
    {
      "id": "NUMANodeSingleCPU",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "NUMA", "CPU", "Memory", "Performance" ],
      "displayName": "Single CPU assigned to NUMA node",
      "description": "Microsoft SQL Server is non-uniform memory access (NUMA) aware. NUMA architecture provides a scalable solution to performance problem. Computers with hardware NUMA have more than one system bus, each serving a small set of processors. Each group of processors has its own memory and possibly its own I/O channels, but each CPU can access memory associated with other groups in a coherent way. Each group is called a NUMA node. The number of CPUs within a NUMA node depends on the hardware vendor. Your hardware manufacturer can tell you if your computer supports hardware NUMA.",
      "message": "Consider assigning additional CPUs to NUMA nodes that have only one assigned CPU",
      "helpLink": "https://docs.microsoft.com/previous-versions/sql/sql-server-2008-r2/ms178144(v=sql.105)",
      "level": "Warning",
      "probes": [ "ServerInstanceConfiguration" ],
      "condition": { "not": "@nodes_single_cpu" }
    },
    {
      "id": "NUMANodeNoCPU",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": "Windows",
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "NUMA", "Performance", "CPU", "Memory" ],
      "displayName": "NUMA nodes without CPUs",
      "description": "Microsoft SQL Server is non-uniform memory access (NUMA) aware. NUMA architecture provides a scalable solution to performance problem. Computers with hardware NUMA have more than one system bus, each serving a small set of processors. Each group of processors has its own memory and possibly its own I/O channels, but each CPU can access memory associated with other groups in a coherent way. Each group is called a NUMA node. The number of CPUs within a NUMA node depends on the hardware vendor. Your hardware manufacturer can tell you if your computer supports hardware NUMA.",
      "message": "Make sure that all NUMA nodes have assigned CPUs",
      "helpLink": "https://docs.microsoft.com/previous-versions/sql/sql-server-2008-r2/ms178144(v=sql.105)",
      "level": "Warning",
      "probes": [ "AffinityNUMANodeNoAssignedCPUs" ],
      "condition": { "not": "@NodeCnt" }
    },
    {
      "id": "IndexKeyGuid",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "tempdb", "model", "msdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Guid in clustered index key column",
      "description": "A big reason for a clustered index is when you often want to retrieve rows for a range of values for a given column. Because the data is physically arranged in that order, the rows can be extracted very efficiently. Something like a GUID, while excellent for a primary key, could be positively detrimental to performance, as there will be additional cost for inserts and no perceptible benefit on selects.",
      "message": "Get rid of GUIDs in the following clustered indexes' keys: @{IndexName}",
      "helpLink": "https://azure.microsoft.com/blog/uniqueidentifier-and-clustered-indexes/",
      "level": "Warning",
      "probes": [ "IndexesGuidKeyColumns" ]
    },
    {
      "id": "IndexesLargeKeys",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,13.0)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Indexes keys with more than 900 bytes",
      "description": "When you design an index that contains many key columns, or large-size columns, calculate the size of the index key to make sure that you do not exceed the maximum index key size. SQL Server retains the 900-byte limit for the maximum total size of all index key columns. This excludes nonkey columns that are included in the definition of nonclustered indexes.",
      "message": "Get rid of keys larger than 900 bytes in index @{FullName}",
      "helpLink": "http://msdn.microsoft.com/library/ms191241.aspx",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": { "le": [ "@KeySize", 900 ] }
    },
    {
      "id": "IndexesLargeKeysNonClust",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[13.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "NonClustered indexes keys with more than 1700 bytes",
      "description": "When you design an index that contains many key columns, or large-size columns, calculate the size of the index key to make sure that you do not exceed the maximum index key size. SQL Server retains the 1700-byte limit for the maximum total size of all non-clustered index key columns. This excludes nonkey columns that are included in the definition of nonclustered indexes.",
      "message": "Get rid of keys larger than 1700 bytes in index @{FullName}",
      "helpLink": "http://msdn.microsoft.com/library/ms191241.aspx",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": [
        { "le": [ "@KeySize", 1700 ] },
        {
          "not": {
            "in": [
              "@Type",
              [ 2, 6 ]
            ]
          }
        }
      ]
    },
    {
      "id": "IndexesLargeKeysClust",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[13.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Clustered indexes keys with more than 900 bytes",
      "description": "When you design an index that contains many key columns, or large-size columns, calculate the size of the index key to make sure that you do not exceed the maximum index key size. SQL Server retains the 900-byte limit for the maximum total size of all clustered index key columns. This excludes nonkey columns that are included in the definition of nonclustered indexes.",
      "message": "Get rid of keys larger than 900 bytes in index @{FullName}",
      "helpLink": "http://msdn.microsoft.com/library/ms191241.aspx",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": [
        { "le": [ "@KeySize", 900 ] },
        {
          "not": {
            "in": [
              "@Type",
              [ 1, 5 ]
            ]
          }
        }
      ]
    },
    {
      "id": "DisabledIndexes",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Disabled Indexes exist",
      "description": "If you need to load a lot of data quickly, you can disable nonclustered indexes in order to improve performance. After the data load finishes, enable the nonclustered indexes again by rebuilding them. This technique works best in large data warehouse environments where entire dimension tables might be reloaded from scratch every night. Disabling nonclustered indexes is safer than dropping and recreating them because scripting indexes is hard. Unfortunately, sometimes our load processes crash before enabling the indexes again, or sometimes we manually load data and we forget to rebuild them.",
      "message": "Remove or enable this disabled index: @{FullName}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/indexes/disable-indexes-and-constraints",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": { "@IsDisabled": false }
    },
    {
      "id": "IndexesFillFactor",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Index fill factor lower 80%",
      "description": "The fill-factor option is provided for fine-tuning index data storage and performance. When an index is created or rebuilt, the fill-factor value determines the percentage of space on each leaf-level page to be filled with data, reserving the remainder on each page as free space for future growth. For example, specifying a fill-factor value of 80 means that 20 percent of each leaf-level page will be left empty, providing space for index expansion as data is added to the underlying table. The empty space is reserved between the index rows rather than at the end of the index.",
      "message": "Review index @{FullName} as its fill factor @{FillFactor} is lower than 80 percent",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/indexes/specify-fill-factor-for-an-index",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": [
        { "less": [ "@FillFactor", 1 ] },
        { "ge": [ "@FillFactor", 80 ] }
      ]
    },
    {
      "id": "NonUniqueClusterIndex",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Non-unique clustered indexes",
      "description": "Index uniqueness is highly desirable attribute of a clustering key, and goes hand-in-hand with index narrowness. SQL Server does not require a clustered index to be unique, but yet it must have some means of uniquely identifying every row. That’s why, for non-unique clustered indexes, SQL Server adds to every duplicate instance of a clustering key value a 4-byte integer value called a uniqueifier. This uniqueifier is added everywhere the clustering key is stored. That means the uniqueifier is stored in both clustered and non-clustered indexes. As you can imagine, if there are many rows using the same clustering key value, this can become quite expensive.",
      "message": "Review this clustered index @{FullName} as it is non-unique",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": [
        { "gt": [ "@Type", 1 ] },
        { "@IsUnique": true }
      ]
    },
    {
      "id": "SuspectPages",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleSet", "Pages", "DataIntegrity" ],
      "displayName": "Suspect pages",
      "description": "The suspect_pages table is used for maintaining information about suspect pages, and is relevant in helping to decide whether a restore is necessary.",
      "message": "Run DBCC CHECKDB to verify affected database. Suspect pages were found: @{EventType}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/backup-restore/manage-the-suspect-pages-table-sql-server",
      "level": "Warning",
      "probes": [ "SuspectPagesValidation" ]
    },
    {
      "id": "SparseFiles",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleSet", "Snapshots", "Backup", "DataIntegrity" ],
      "displayName": "Sparse files",
      "description": "If the file is sparse or compressed, the NTFS file system may deallocate disk space in the file. This sets the range of bytes to zeroes (0) without extending the file size.",
      "message": "Get rid of sparse files: @{SparseFiles}",
      "helpLink": "https://blogs.msdn.microsoft.com/jorgepc/2010/11/25/what-are-sparse-files-and-why-should-i-care-as-sql-server-dba/",
      "level": "Warning",
      "probes": [ "SparseFilesValidation" ]
    },
    {
      "id": "TableNoIndex",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "tempdb", "model", "msdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Tables without indexes",
      "description": "Each table in the database has one or more pages. To keep track of those pages, SQL Server uses a special set of pages, called IAM (for Index Allocation Map) pages. In spite of the word “Index” in the name, IAMs are used for non-indexed tables as well. These are called heaps. All the data is there, but the only way to find anything is to read it starting at the beginning. For a very large table, this will be terribly inefficient.",
      "message": "Review table @{TableName} and create reasonable indexes",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/indexes/heaps-tables-without-clustered-indexes",
      "level": "Warning",
      "probes": [ "TableIndexes" ],
      "condition": [
        { "gt": [ "@IndexCount", 1 ] },
        { "gt": [ "@MaxIndexId", 0 ] }
      ]
    },
    {
      "id": "TableNoClusteredIndex",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "tempdb", "model", "msdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Tables without clustered indexes",
      "description": "Tables without clustered indexes are called heaps. They’re scattered on disk anywhere that SQL Server can find a spot, and they’re not stored in any order whatsoever. This can make for really fast inserts – SQL Server can just throw the data down – but slow selects, updates, and deletes.",
      "message": "Review table @{TableName} and consider creating a clustered index",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/indexes/heaps-tables-without-clustered-indexes",
      "level": "Warning",
      "probes": [ "TableIndexes" ],
      "condition": [
        { "le": [ "@IndexCount", 1 ] },
        { "gt": [ "@MinIndexId", 0 ] }
      ]
    },
    {
      "id": "TablePSAlign",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "name": { "not": ["master", "tempdb", "model", "msdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Table index not aligned with PS",
      "description": "Table partitioning is a complex way to break out your large tables into smaller, more manageable chunks, but it comes with a lot of management heartache. One of the challenges is making sure that your indexes are partitioned and aligned the same way as your clustered index.",
      "message": "Consider recreating index @{IndexName} in table @{TableName} to have it aligned with your schema",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/partitions/partitioned-tables-and-indexes",
      "level": "Warning",
      "probes": [ "TableIndexesPartitioned" ]
    },
    {
      "id": "LoginNoPassword",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Security", "WeakPassword" ],
      "displayName": "Logins with no passwords",
      "description": "Password complexity policies are designed to deter brute force attacks by increasing the number of possible passwords.",
      "message": "Make sure to set strong passwords on the following logins: @{PasswordData}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/security/password-policy",
      "probes": [ "NullPassword" ]
    },
    {
      "id": "LoginEqPassword",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Security", "WeakPassword" ],
      "displayName": "Logins with passwords that are same as the login names",
      "description": "Password complexity policies are designed to deter brute force attacks by increasing the number of possible passwords.",
      "message": "Please review logins with password equals to login: @{PasswordData}",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/security/password-policy",
      "probes": [ "NamePassword" ]
    },
    {
      "id": "SystemHealth",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "XEvent", "SystemHealth", "Performance" ],
      "displayName": "System Health important messages",
      "description": "The system_health session is an Extended Events session that is included by default with SQL Server. This session starts automatically when the SQL Server Database Engine starts, and runs without any noticeable performance effects. The session collects system data that you can use to help troubleshoot performance issues in the Database Engine",
      "message": "Error @{Error_Number} has occured @{Error_Count} times. Last time was @{Last_Logged_Days_Ago} days ago",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/extended-events/use-the-system-health-session",
      "level": "Warning",
      "probes": [ "SystemHealth" ]
    },
    {
      "id": "RarelyUsedIndex",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Indexes", "Performance" ],
      "displayName": "Rarely used index",
      "description": "Rarely used indexes can slow down database's performance. Time of write operations is increased because of index maintenance, but index is not used quite often. It makes sense to compare impact of writing operations versus rare reading speedup.",
      "message": "Make sure you need index @{IndexName} as it's used too rarely",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/drop-index-transact-sql",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": [
        { "@Hits": 0 },
        { "ge": [ "@ReadsRatio", "@ReadsThreshold" ] },
        { "@IsPrimaryKey": true }
      ],
      "ReadsThreshold": 5
    },
    {
      "id": "UnusedIndex",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Index", "Performance" ],
      "displayName": "Unused index",
      "description": "Unused indexes can slow down database's performance. Time of write operations is increased because of index maintenance, but index is not used anywhere.",
      "message": "Make sure you need index @{IndexName} as it's unused",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/drop-index-transact-sql",
      "level": "Warning",
      "probes": [ "IndexesDefinitions" ],
      "condition": [
        {
          "and": [
            { "ne": [ "@Type", 2 ] },
            { "ne": [ "@Type", 6 ] }
          ]
        },
        { "@IsPrimaryKey": true },
        { "gt": [ "@Hits", 0 ] }
      ]
    },
    {
      "id": "SkewedCompatibilityLevel",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "CompatibilityLevel", "Security", "Performance", "UpdateIssues" ],
      "displayName": "Database with skewed compatibility level",
      "description": "Some databases may have a compatibility level lower than the allowed level by the Database Engine.",
      "message": "Update database compatibility level (current level: @{CompatibilityLevel})",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/alter-database-transact-sql-compatibility-level",
      "level": "Warning",
      "probes": [ "CompatibilityLevel", "SQLServerVersion" ],
      "condition": {
        "ge": [
          { "div": [ "@CompatibilityLevel", 10 ] },
          "@ServerMajorVersion"
        ]
      }
    },
    {
      "id": [ "DefaultRuleset" ],
      "itemType": "override",
      "targetFilter": {
        "type": "Database",
        "name": [ "virtualmanagerdb", "scspfdb", "semanticsdb", "servicemanager", "service manager", "dwstagingandconfig", "dwrepository", "dwdatamart", "dwasdatabase", "omdwdatamart", "cmdwdatamart", "ssodb", "bamanalysis", "bamarchive", "bamalertsapplication", "bamalertsnsmain", "bamprimaryimport", "bamstarschema", "biztalkmgmtdb", "biztalkmsgboxdb", "biztalkdtadb", "biztalkruleenginedb", "bamprimaryimport", "biztalkedidb", "biztalkhwsdb", "tpm", "biztalkanalysisdb", "bamprimaryimportsuccessfully", "aspstate", "aspnet", "mscrm_config", "cpsdyn", "lcslog", "lcscdr", "lis", "lyss", "mgc", "qoemetrics", "rgsconfig", "rgsdyn", "rtc", "rtcab", "rtcab1", "rtcdyn", "rtcshared", "rtcxds", "xds", "activitylog", "branchdb", "clienttracelog", "eventlog", "listingssettings", "servicegroupdb", "tservercontroller", "vodbackend", "operationsmanager", "operationsmanagerdw", "operationsmanagerac", "orchestrator", "sso", "wss_search", "wss_search_config", "sharedservices_db", "sharedservices_search_db", "wss_content", "profiledb", "social db", "sync db", "susdb", "projectserver_archive", "projectserver_draft", "projectserver_published", "projectserver_reporting", "reportserver", "reportservertempdb", "rsdb", "rstempdb", "fastsearchadmindatabase", "ppsmonitoring", "ppsplanningservice", "ppsplanningsystem", "dynamics", "microsoftdynamicsax", "microsoftdynamicsaxbaseline", "fimservice", "fimsynchronizationservice", "sbgatewaydatabase", "sbmanagementdb", "wfinstancemanagementdb", "wfmanagementdb", "wfresourcemanagementdb" ]
      },
      "enabled": false
    },
    {
      "id": "PendingDiskIORequests",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "IO", "Performance" ],
      "displayName": "Pending disk I/O requests",
      "description": "A database management system (DBMS), such as SQL Server, relies on the timeliness of file input and output (I/O) operations. The proper configuration and maintenance of the I/O subsystem is critical to a successful SQL Server deployment.",
      "message": "Investigate and solve I/O related issues to get rid of pending requests",
      "helpLink": "https://support.microsoft.com/en-sg/help/897284/diagnostics-in-sql-server-help-detect-stalled-and-stuck-i-o-operations",
      "level": "Warning",
      "probes": [
        {
          "id": "PendingIORequests",
          "params": {
            "io_type": "disk"
          }
        }
      ]
    },
    {
      "id": "MaxDOP",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "MaxDOP", "Performance", "Configuration", "NUMA", "CPU" ],
      "displayName": "MaxDOP should be less or equal number of CPUs",
      "description": "The Microsoft SQL Server max degree of parallelism (MAXDOP) configuration option controls the number of processors that are used for the execution of a query in a parallel plan. This option determines the number of threads that are used for the query plan operators that perform the work in parallel. Depending on whether SQL Server is set up on a symmetric multiprocessing (SMP) computer, a non-uniform memory access (NUMA) computer, or hyperthreading-enabled processors, the max degree of parallelism option should be configured appropriately.",
      "message": "Update MaxDOP configuration option – it shouldn't exceed the number of processors that SQL Server uses",
      "helpLink": "https://support.microsoft.com/kb/2806535",
      "level": "Warning",
      "probes": [ "ServerInstanceConfiguration" ],
      "condition": {
        "le": [ "@MaxDOP", "@online_logical_processors" ]
      }
    },
    {
      "id": "MaxDOPOver8CPU1NUMA",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "MaxDOP", "Performance", "Configuration", "NUMA", "CPU" ],
      "displayName": "MaxDOP should equal number of CPUs for single NUMA node",
      "description": "The Microsoft SQL Server max degree of parallelism (MAXDOP) configuration option controls the number of processors that are used for the execution of a query in a parallel plan. This option determines the number of threads that are used for the query plan operators that perform the work in parallel. Depending on whether SQL Server is set up on a symmetric multiprocessing (SMP) computer, a non-uniform memory access (NUMA) computer, or hyperthreading-enabled processors, the max degree of parallelism option should be configured appropriately.",
      "message": "Update MaxDOP configuration option – it should equal the number of processors that SQL Server uses",
      "helpLink": "https://support.microsoft.com/kb/2806535",
      "level": "Warning",
      "probes": [ "ServerInstanceConfiguration" ],
      "condition": [
        { "ne": [ "@numa_nodes", 1 ] },
        { "gt": [ "@online_logical_processors", 8 ] },
        { "@MaxDOP": 0 },
        { "@MaxDOP": "@online_logical_processors" }
      ]
    },
    {
      "id": "MaxDOP8CPU1NUMA",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": ["DefaultRuleset", "MaxDOP", "Performance", "Configuration", "NUMA", "CPU"],
      "displayName": "MaxDOP should be less 8 for single NUMA node",
      "description": "The Microsoft SQL Server max degree of parallelism (MAXDOP) configuration option controls the number of processors that are used for the execution of a query in a parallel plan. This option determines the number of threads that are used for the query plan operators that perform the work in parallel. Depending on whether SQL Server is set up on a symmetric multiprocessing (SMP) computer, a non-uniform memory access (NUMA) computer, or hyperthreading-enabled processors, the max degree of parallelism option should be configured appropriately.",
      "message": "Update MaxDOP configuration option – it shouldn't exceed 8",
      "helpLink": "https://support.microsoft.com/kb/2806535",
      "level": "Warning",
      "probes": [ "ServerInstanceConfiguration" ],
      "condition": [
        { "ne": [ "@numa_nodes", 1 ] },
        { "le": [ "@online_logical_processors", 8 ] },
        {
          "gt": [ "@MaxDOP", 0 ],
          "le": [ "@MaxDOP", 8 ]
        }
      ]
    },
    {
      "id": "MaxDOPFewNUMA",
      "itemType": "definition",
      "target": {
        "type": "Server",
        "platform": ["Windows", "Linux"],
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "MaxDOP", "Performance", "Configuration", "NUMA", "CPU" ],
      "displayName": "MaxDOP should be according to processor count ratio",
      "description": "The Microsoft SQL Server max degree of parallelism (MAXDOP) configuration option controls the number of processors that are used for the execution of a query in a parallel plan. This option determines the number of threads that are used for the query plan operators that perform the work in parallel. Depending on whether SQL Server is set up on a symmetric multiprocessing (SMP) computer, a non-uniform memory access (NUMA) computer, or hyperthreading-enabled processors, the max degree of parallelism option should be configured appropriately.",
      "message": "Update MaxDOP configuration option – if the number of CPUs per NUMA <= 15, then set MaxDOP the same number, if it's > 15, then set MaxDOP = half of it",
      "helpLink": "https://support.microsoft.com/kb/2806535",
      "level": "Warning",
      "probes": [ "ServerInstanceConfiguration" ],
      "condition": [
        { "le": [ "@numa_nodes", 1 ] },
        {
          "and": [
            {
              "or": [
                {
                  "ge": [
                    { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] },
                    8
                  ]
                },
                {
                  "gt": [ "@MaxDOP", 0 ],
                  "le": [
                    "@MaxDOP",
                    { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] }
                  ]
                }
              ]
            },
            {
              "or": [
                {
                  "lt": [
                    { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] },
                    8
                  ]
                },
                {
                  "gt": [ "@MaxDOP", 0 ],
                  "and": [
                    { "le": [ "@MaxDOP", 8 ] },
                    {
                      "le": [
                        "@MaxDOP",
                        { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "MaxDOPFewNUMA",
      "itemType": "override",
      "targetFilter": {
        "version": "[13.0,)"
      },
      "condition": [
        { "le": [ "@numa_nodes", 1 ] },
        {
          "and": [
            {
              "or": [
                {
                  "gt": [
                    { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] },
                    15
                  ]
                },
                {
                  "gt": [ "@MaxDOP", 0 ],
                  "le": [
                    "@MaxDOP",
                    { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] }
                  ]
                }
              ]
            },
            {
              "or": [
                {
                  "le": [
                    { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] },
                    15
                  ]
                },
                {
                  "gt": [ "@MaxDOP", 0 ],
                  "le": [
                    "@MaxDOP",
                    {
                      "div": [
                        { "ceiling": [ { "div": [ "@total_logical_processors", "@numa_nodes" ] } ] },
                        2
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "DbIntegrity",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": "tempdb" },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBCC", "Performance", "DataIntegrity" ],
      "displayName": "Database Integrity Checks",
      "description": "The DBCC CHECKDB command checks the integrity of the objects in a database and should be run on a regular basis. This statement is used to perform different operations in your database and can be broken down into four categories: Maintenance, Miscellaneous, Informational, and Validation.",
      "message": "Run DBCC CHECKDB since integrity checks have not been executed for over 7 days",
      "helpLink": "https://msdn.microsoft.com/library/ms176064.aspx",
      "level": "Warning",
      "probes": [ "DBMetaInfo", "DatabaseConfiguration" ],
      "condition": [
        { "@IsReadOnly": true },
        { "ne": [ "@DbState", 0 ] },
        { "le": [ "@LastKnownDBCCDaysAgo", 7 ] }
      ]
    },
    {
      "id": "DirectCatalogUpdates",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": "tempdb" },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBCC", "Deprecated" ],
      "displayName": "Direct Catalog Updates",
      "description": "'allow updates' option is still present in the sp_configure stored procedure, although its functionality is unavailable in SQL Server. The setting has no effect. Starting with SQL Server 2005, direct updates to the system tables are not supported.",
      "message": "Do not use direct catalog update feature in new development work, and modify applications that currently use it as soon as possible",
      "helpLink": "https://docs.microsoft.com/sql/database-engine/configure-windows/allow-updates-server-configuration-option",
      "level": "Warning",
      "probes": [ "DBMetaInfo", "DatabaseConfiguration" ],
      "condition": [
        { "@IsReadOnly": true },
        { "ne": [ "@DbState", 0 ] },
        { "@UpdSysCatalog": 0 }
      ]
    },
    {
      "id": "DataPurityCheck",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "DBCC", "DataIntegrity" ],
      "displayName": "Data Purity Check",
      "description": "The DBCC CHECKDB command checks the integrity of the objects in a database and should be run on a regular basis. One thing that this command does not check in databases created in versions prior to SQL Server 2005 is the integrity of the data in the columns until it has been run once with the DATA_PURITY option. Adding the DATA_PURITY option causes the CHECKDB command to look for column values that are invalid or out of range. Any database that was created in SQL Server 2005 or later will include the DATA_PURITY check by default; but if the database is being upgraded from an earlier version, you must run the command with the DATA_PURITY option at least once using the following command and then fix any data issues.",
      "message": "Run DBCC CHECKDB ([DatabaseName]) WITH DATA_PURITY",
      "helpLink": "http://support.microsoft.com/kb/923247",
      "level": "Warning",
      "probes": [ "DBMetaInfo", "DatabaseConfiguration" ],
      "condition": [
        { "@IsReadOnly": true },
        { "ne": [ "@DbState", 0 ] },
        { "gt": [ "@CreateVersion", 611 ] },
        { "ne": [ "@DBCCFlags", 0 ] }
      ]
    },
    {
      "id": "StatSamplingRate",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "Statistics" ],
      "displayName": "Statistics sampling rate",
      "description": "For most queries, the Query Optimizer already generates the necessary statistics for a high quality query plan; in some cases, you need to create additional statistics or modify the query design for best results.",
      "message": "Some statistics have sampling rates less than @{threshold:P}, consider updating with a larger sample or full scan if key is not uniformly distributed. Affected tables: @{FullName}.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/update-statistics-transact-sql",
      "level": "Warning",
      "threshold": 0.25,
      "probes": [
        {
          "id": "StatSamplingRate",
          "params": {
            "threshold": "@threshold"
          },
          "transform": {
            "type": "aggregate",
            "map": {
              "FullName": "join"
            }
          }
        }
      ]
    },
    {
      "id": "IndexFragmentation",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Index", "Performance" ],
      "displayName": "Index Fragmentation",
      "description": "The SQL Server Database Engine automatically modifies indexes whenever insert, update, or delete operations are made to the underlying data. Over time these modifications can cause the information in the index to become scattered in the database (fragmented). Fragmentation exists when indexes have pages in which the logical ordering, based on the key value, does not match the physical ordering inside the data file. Heavily fragmented indexes can degrade query performance and cause your application to respond slowly, especially scan operations.",
      "message": "Remove fragmentation of index @{IndexFullName}. It's fragmentation level: @{fragmentation:#0.##}%.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/indexes/reorganize-and-rebuild-indexes",
      "level": "Warning",
      "probes": [ "IndexStatistics" ],
      "condition": [
        { "le": [ "@fragmentation", "@threshold" ] },
        { "le": [ "@page_count", 8 ] }
      ],
      "threshold": 5
    },
    {
      "id": "IndexFragmentation",
      "itemType": "override",
      "targetFilter": {
        "version": "[12.0,)"
      },
      "condition": {
        "and": [
          {
            "or": [
              { "le": [ "@fragmentation", "@threshold" ] },
              { "le": [ "@page_count", 8 ] }
            ]
          },
          {
            "or": [
              {
                "not": {
                  "in": [
                    "@IndexType",
                    [ 5, 6 ]
                  ]
                }
              },
              { "le": [ "@fragmentation_CI", "@threshold" ] },
              { "ne": [ "@state", 3 ] }
            ]
          }
        ]
      }
    },
    {
      "id": "XTPHashAvgChainBuckets",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[12.0,)"
      },
      "tags": [ "DefaultRuleset", "Index", "Performance", "XTP" ],
      "displayName": "High avg chain length and empty buckets",
      "description": "Memory-optimized HASH indexes behave different from NONCLUSTERED indexes. They are optimized for point-lookup operations, and do not support ordered scans or inequality seek operations. You should specify a value for the BUCKET_COUNT parameter when you create a memory-optimized table.",
      "message": "Index @{IndexFullName} has @{avg_chain_length} average chain length and @{EmptyBucketPct}% empty buckets count. Verify if there are many rows with duplicate index key values or there is a skew in the key values",
      "helpLink": "https://techcommunity.microsoft.com/t5/sql-server/in-memory-oltp-indexes-part-2-performance-troubleshooting-guide/ba-p/385725",
      "level": "Warning",
      "probes": [ "XTPIndexHashStatistics" ],
      "condition": [
        { "le": [ "@EmptyBucketPct", "@EmptyBucketsPctThreshold" ] },
        { "le": [ "@avg_chain_length", 5 ] }
      ],
      "EmptyBucketsPctThreshold": 50 
    },
    {
      "id": "XTPTooManyBuckets",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[12.0,)"
      },
      "tags": [ "DefaultRuleset", "Index", "Performance", "XTP" ],
      "displayName": "Too many buckets",
      "description": "Memory-optimized HASH indexes behave different from NONCLUSTERED indexes. They are optimized for point-lookup operations, and do not support ordered scans or inequality seek operations. You must specify a value for the BUCKET_COUNT parameter when you create the memory-optimized table.",
      "message": "Make number of buckets of index @{IndexFullName} equal to distinct rows. It has @{total_bucket_count} buckets, and there are @{DistinctCnt} in the table, which is wasting memory and marginally slowing down full table scans.",
      "helpLink": "https://techcommunity.microsoft.com/t5/sql-server/in-memory-oltp-indexes-part-2-performance-troubleshooting-guide/ba-p/385725",
      "level": "Warning",
      "probes": [ "XTPIndexHashStatistics" ],
      "condition": [
        { "le": [ "@total_bucket_count", "@DistinctCnt" ] }
      ]
    },
    {
      "id": "XTPTooFewBuckets",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[12.0,)"
      },
      "tags": [ "DefaultRuleset", "Index", "Performance", "XTP" ],
      "displayName": "Too few buckets",
      "description": "Memory-optimized HASH indexes behave different from NONCLUSTERED indexes. They are optimized for point-lookup operations, and do not support ordered scans or inequality seek operations. You must specify a value for the BUCKET_COUNT parameter when you create the memory-optimized table.",
      "message": "Make number of buckets of index @{IndexFullName} equal to distinct rows. It has @{total_bucket_count} buckets, and there are @{DistinctCnt} in the table, which leads to chaining records.",
      "helpLink": "https://techcommunity.microsoft.com/t5/sql-server/in-memory-oltp-indexes-part-2-performance-troubleshooting-guide/ba-p/385725",
      "level": "Warning",
      "probes": [ "XTPIndexHashStatistics" ],
      "condition": [
        { "ge": [ "@total_bucket_count", "@DistinctCnt" ] }
      ]
    },
    {
      "id": "XTPRangeIXHealth",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[12.0,)"
      },
      "tags": [ "DefaultRuleset", "Index", "Performance", "XTP" ],
      "displayName": "NonClustered index retry amount",
      "description": "When a database with a memory-optimized table is restarted, the index is built by inserting one row at a time into memory. The count of page splits, merges, and consolidation can help you understand the work done to build the index when a database is brought online. Large numbers of retries are indicative of concurrency issues.",
      "message": "Review index @{IndexFullName} as its retry count is over @{RetryCountPct}% of total, which is indicating possible concurrency issues.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-nonclustered-index-stats-transact-sql",
      "level": "Warning",
      "probes": [ "XTPNonClusteredIndexHashStatistics" ],
      "condition": {
        "and": [
          { "le": [ "@page_update_count_pct", "@RetryCountPct" ] },
          { "le": [ "@page_consolidation_count_pct", "@RetryCountPct" ] },
          { "le": [ "@page_split_count_pct", "@RetryCountPct" ] },
          { "le": [ "@key_split_count_pct", "@RetryCountPct" ] },
          { "le": [ "@page_merge_count_pct", "@RetryCountPct" ] },
          { "le": [ "@key_merge_count_pct", "@RetryCountPct" ] }
        ] 
      },
      "RetryCountPct": 5 
    },
    {
      "id": "TF6533Misuse",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "version": [
          "[11.0.6020, 11.0.6518)"
        ],
        "platform": "Windows",
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises"
      },
      "tags": [ "DefaultRuleset", "TraceFlag", "Performance", "TF6533" ],
      "displayName": "STRelate and STAsBinary functions unexpected results due to enabled TF 6533",
      "description": "The STRelate and STAsBinary functions may return unexpected results when trace flag 6533 is enabled. Do not use this trace flag if your workload involves either of these functions.",
      "message": "Disable TF 6533 to avoid unexpected results of functions STRelate and STAsBinary",
      "helpLink": "https://support.microsoft.com/help/3107399",
      "level": "Warning",
      "probes": [ "EnabledGlobalTraceFlags", "TF6533SpatialFunctionsUsage" ],
      "condition": [
        { "not": { "in": [ 6533, "@TraceFlag" ] } },
        { "@InUse": 0 }
      ]
    },
    {
      "id": "UntrustedConstraints",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "DataIntegrity" ],
      "displayName": "Untrusted Constraints",
      "description": "If you need to load a lot of data quickly, you can disable keys and constraints in order to improve performance. After the data load finishes, enable them again, and SQL Server will check them behind the scenes. This technique works best in large data warehouse environments where entire dimension tables might be reloaded from scratch every night. Disabling constraints is usually safer and easier than dropping and recreating them.",
      "message": "Execute ALTER TABLE <table name> WITH CHECK CHECK CONSTRAINT <constraint name> statement to avoid possible performance issues: @{constraint_name} constraints are not trusted for referential integrity.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/alter-table-transact-sql",
      "level": "Warning",
      "probes": [ "FKNotTrusted" ]
    },
    {
      "id": "PercentAutogrows",
      "itemType": "definition",
      "target": { 
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises",
        "name": { "not": ["master", "model", "msdb", "tempdb"] },
        "version": "[11.0,)"
      },
      "tags": [ "DefaultRuleset", "Performance", "DBFileConfiguration", "DBConfiguration" ],
      "displayName": "Database files have a growth ratio set in percentage",
      "description": "Some database files have a growth ratio set in percentage. Over time, this could lead to uncontrolled disk space allocation and extended time to perform these growths",
      "message": "Don't use \"File Growth In Percent\" for the Autogrowth setting. The following files are affected: @{fileName} have a growth ratio set in percentage.",
      "helpLink": "https://docs.microsoft.com/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options",
      "level": "Warning",
      "probes": [
        {
          "id": "DatabaseMasterFiles",
          "params": {
            "type": null,
            "is_percent_growth": 1
          },
          "transform": {
            "type": "aggregate",
            "map": {
              "fileName": "join"
            }
          }
        }
      ]
    },
    {
      "id": "StatsUpdate",
      "itemType": "definition",
      "target": {
        "type": "Database",
        "platform": ["Windows", "Linux"],
        "engineEdition": "OnPremises, ManagedInstance",
        "version": "[11.0,)"
      },
      "tags": ["DefaultRuleset", "Performance", "Statistics", "QueryOptimizer"],
      "displayName": "Statistics needs to be updated",
      "description": "The Query Optimizer determines whether an index is useful for a specific query by evaluating the stored statistics. If the statistics become out of date and significant changes have occurred against the underlying data, this can result in less than optimal query performance. In most cases, it's best to let SQL Server maintain the statistics. If you turn 'Auto Create Stats' and 'Auto Update Stats' off, then it is up to you to keep the statistics up-to-date somehow. Failure to do so will lead to poor query performance. Most applications should have these options ON. When the Auto Update Statistics setting is ON, the Query Optimizer updates statistics when they are used by a query and when they might be out-of-date. Statistics become out-of-date after insert, update, delete, or merge operations change the data distribution in the table or indexed view. The Query Optimizer determines when statistics might be out-of-date by counting the number of data modifications since the last statistics update and comparing the number of modifications to a threshold. The threshold is based on the number of rows in the table or indexed view. The Query Optimizer checks for out-of-date statistics before compiling a query and before executing a cached query plan. Before compiling a query, the Query Optimizer uses the columns, tables, and indexed views in the query predicate to determine which statistics might be out-of-date. Before executing a cached query plan, the Database Engine verifies that the query plan references up-to-date statistics. The AUTO_UPDATE_STATISTICS option applies to statistics created for indexes, single-columns in query predicates, and statistics that are created by using the CREATE STATISTICS statement. This option also applies to filtered statistics.",
      "message": "Update stats in table @{TableName} to improve query performance.",
      "helpLink": "https://docs.microsoft.com/sql/relational-databases/statistics/statistics#UpdateStatistics",
      "probes": ["DatabaseConfiguration", "ObjectStatistics"],
      "condition": [
        "@is_auto_update_stats_on",
        {
          "and": [
            {
              "or": [
                { "gt": [ "@rows", "@threshold" ] },
                { "lt": [ "@modification_counter", "@threshold" ] }
              ]
            },
            {
              "or": [
                { "le": [ "@rows", "@threshold" ] },
                {
                  "lt": [
                    "@modification_counter",
                    {
                      "add": [
                        "@threshold",
                        { "mul": [ "@rows", 0.2 ] }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "threshold": 500
    }
  ],
  "probes": {
    "EnabledGlobalTraceFlags": [
      {
        "type": "SQL",
        "target": {
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DECLARE @tracestatus TABLE (TraceFlag NVARCHAR(40), [Status] tinyint, [Global] tinyint, [Session] tinyint); INSERT INTO @tracestatus EXEC ('DBCC TRACESTATUS WITH NO_INFOMSGS'); IF NOT EXISTS(SELECT * FROM @tracestatus WHERE Global=1) SELECT 0 AS [TraceFlag], 0 AS [Status] ELSE SELECT [TraceFlag], [Status] FROM @tracestatus WHERE Global=1",
          "transform": {
            "type": "aggregate",
            "map": {
              "TraceFlag": "array"
            }
          }
        }
      }
    ],
    "CountBlackBoxTraces": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT COUNT(id) AS [BlackBoxTraceCount] FROM [sys].[traces] WHERE [path] LIKE '%blackbox%.trc' AND status=1;"
        }
      }
    ],
    "CountDefaultTraces": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT COUNT(id) AS [DefaultTraceCount] FROM [sys].[traces] WHERE is_default = 1 AND status = 1;"
        }
      }
    ],
    "XEvent.SystemHealth": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT COUNT(name) AS [XEvent.SystemHealthCount] FROM [sys].[dm_xe_sessions] WHERE [name] = 'system_health';"
        }
      }
    ],
    "XEvent.SPServerDiagnostics": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT COUNT(name) AS [XEvent.SPServerDiagnostics] FROM sys.dm_xe_sessions WHERE [name] = 'sp_server_diagnostics session';"
        }
      }
    ],
    "DeprecatedFeaturesStats": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT [instance_name] AS [DeprecatedFeature] FROM [sys].[dm_os_performance_counters] WHERE ([object_name] LIKE '%Deprecated Features%') AND ([cntr_value] > 0);",
          "transform": {
            "type": "aggregate",
            "map": {
              "DeprecatedFeature": "join"
            }
          }
        }
      }
    ],
    "DatabaseConfiguration": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "version": "[11.0,12.0)",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance"
        },
        "implementation": {
          "query": "SELECT db.is_auto_create_stats_on, db.is_auto_update_stats_on, 0 AS query_store_state, db.collation_name, (SELECT collation_name FROM master.sys.databases (NOLOCK) WHERE database_id = 1) AS master_collation, db.is_auto_close_on, db.is_auto_shrink_on, db.page_verify_option, db.is_db_chaining_on, NULL AS is_auto_create_stats_incremental_on, db.is_trustworthy_on, db.is_parameterization_forced,db.is_read_only AS IsReadOnly,db.[state] AS DbState FROM [sys].[databases] (NOLOCK) AS db WHERE db.[name]=@TargetName"
        }
      },
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "version": "[12.0, 13.0)",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance"
        },
        "implementation": {
          "query": "SELECT db.is_auto_create_stats_on, db.is_auto_update_stats_on, 0 AS query_store_state, db.collation_name, (SELECT collation_name FROM master.sys.databases (NOLOCK) WHERE database_id = 1) AS master_collation, db.is_auto_close_on, db.is_auto_shrink_on, db.page_verify_option, db.is_db_chaining_on, db.is_auto_create_stats_incremental_on, db.is_trustworthy_on, db.is_parameterization_forced,db.is_read_only AS IsReadOnly,db.[state] AS DbState FROM [sys].[databases] (NOLOCK) AS db WHERE db.[name]=@TargetName"
        }
      },
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "version": "[13.0,)",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT db.is_auto_create_stats_on, db.is_auto_update_stats_on, (SELECT CAST(actual_state AS DECIMAL) FROM [sys].[database_query_store_options]) AS query_store_state, db.collation_name, (SELECT collation_name FROM master.sys.databases (NOLOCK) WHERE database_id = 1) AS master_collation, db.is_auto_close_on, db.is_auto_shrink_on, db.page_verify_option, db.is_db_chaining_on, db.is_auto_create_stats_incremental_on, db.is_trustworthy_on, db.is_parameterization_forced,db.is_read_only AS IsReadOnly,db.[state] AS DbState FROM [sys].[databases] (NOLOCK) AS db WHERE db.[name]=@TargetName"
        }
      }
    ],
    "FKNoIndexes": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT QUOTENAME(fk.parent_schema_name)+ '.' + QUOTENAME(fk.parent_table_name) + '.' + QUOTENAME(fk.constraint_name) AS ConstraintName  FROM ( SELECT t.name AS [parent_schema_name], OBJECT_NAME(FKC.parent_object_id) [parent_table_name], OBJECT_NAME(constraint_object_id) AS [constraint_name], SUBSTRING((SELECT ',' + RTRIM(COL_NAME(k.parent_object_id,parent_column_id)) AS [data()] FROM sys.foreign_key_columns k (NOLOCK) INNER JOIN sys.foreign_keys (NOLOCK) ON k.constraint_object_id = [object_id] AND k.constraint_object_id = FKC.constraint_object_id ORDER BY constraint_column_id FOR XML PATH('')), 2, 8000) AS [parent_columns]  FROM sys.foreign_key_columns FKC (NOLOCK) INNER JOIN sys.objects o (NOLOCK) ON FKC.parent_object_id = o.[object_id] INNER JOIN sys.tables mst (NOLOCK) ON mst.[object_id] = o.[object_id] INNER JOIN sys.schemas t (NOLOCK) ON t.[schema_id] = mst.[schema_id] INNER JOIN sys.objects so (NOLOCK) ON FKC.referenced_object_id = so.[object_id] WHERE o.type = 'U' AND so.type = 'U' GROUP BY o.[schema_id],so.[schema_id],FKC.parent_object_id,constraint_object_id,referenced_object_id,t.name ) fk WHERE NOT EXISTS (SELECT 1 FROM (  SELECT t.name AS schemaName, OBJECT_NAME(mst.[object_id]) AS objectName, SUBSTRING(( SELECT ',' + RTRIM(ac.name) FROM sys.tables AS st INNER JOIN sys.indexes AS mi ON st.[object_id] = mi.[object_id] INNER JOIN sys.index_columns AS ic ON mi.[object_id] = ic.[object_id] AND mi.[index_id] = ic.[index_id]  INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id] WHERE i.[object_id] = mi.[object_id] AND i.index_id = mi.index_id AND ic.is_included_column = 0 ORDER BY ac.column_id  FOR XML PATH('')), 2, 8000) AS KeyCols  FROM sys.indexes AS i  INNER JOIN sys.tables AS mst ON mst.[object_id] = i.[object_id]  INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]  WHERE i.[type] IN (1,2,5,6) AND i.is_unique_constraint = 0 AND mst.is_ms_shipped = 0 ) ict  WHERE fk.parent_schema_name = ict.schemaName AND fk.parent_table_name = ict.objectName  AND REPLACE(fk.parent_columns,' ,',',') = ict.KeyCols);",
          "transform": {
            "type": "aggregate",
            "map": {
              "ConstraintName": "join"
            }
          }
        }
      }
    ],
    "Hints.InstanceStatistics": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT COUNT([counter]) AS [HintUsageCount] FROM [sys].[dm_exec_query_optimizer_info] WHERE ([counter] = 'order hint' OR [counter] = 'join hint') AND occurrence > 1;"
        }
      }
    ],
    "Hints.ModuleUsage": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT ss.name AS [Schema_Name], so.name AS [Object_Name], so.type_desc, CASE WHEN sm.[definition] LIKE '%FORCE ORDER%' THEN '[FORCE ORDER Hint]' WHEN sm.[definition] LIKE '%MERGE JOIN%' OR sm.[definition] LIKE '%LOOP JOIN%' OR sm.[definition] LIKE '%HASH JOIN%' THEN '[JOIN Hint]' END AS Hint FROM [sys].[sql_modules] AS sm INNER JOIN [sys].[objects] AS so ON sm.[object_id] = so.[object_id] INNER JOIN [sys].[schemas] AS ss ON so.[schema_id] = ss.[schema_id] WHERE (sm.[definition] LIKE '%FORCE ORDER%' OR sm.[definition] LIKE '%MERGE JOIN%' OR sm.[definition] LIKE '%LOOP JOIN%' OR sm.[definition] LIKE '%HASH JOIN%') AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped') = 0;"
        }
      }
    ],
    "CachedPlans.SingleUseRatio": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DECLARE @Size1 AS REAL, @Size2 AS REAL; SET @Size1=COALESCE((SELECT SUM(CAST(size_in_bytes AS bigint)) AS Size1 FROM [sys].[dm_exec_cached_plans] (NOLOCK) WHERE cacheobjtype LIKE '%Plan%' AND usecounts = 1),0);SET @Size2=COALESCE((SELECT SUM(CAST(size_in_bytes AS bigint)) AS Size2 FROM [sys].[dm_exec_cached_plans] (NOLOCK) WHERE cacheobjtype LIKE '%Plan%' AND usecounts > 1),0);SELECT @Size1/(@Size1+@Size2) AS [SingleUsePlansUseRatio];"
        }
      }
    ],
    "Hypothetical.Indexes": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT QUOTENAME(t.name) AS [Schema], QUOTENAME(o.[name]) AS [Object], i.name AS [IndexName] FROM [sys].[indexes] i INNER JOIN [sys].[objects] AS o ON o.[object_id] = i.[object_id] INNER JOIN [sys].[tables] AS mst ON mst.[object_id] = i.[object_id] INNER JOIN [sys].[schemas] AS t ON t.[schema_id] = mst.[schema_id] WHERE i.is_hypothetical = 1;"
        }
      }
    ],
    "Hypothetical.Statistics": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT QUOTENAME(t.name) AS [Schema], QUOTENAME(o.[name]) AS [Object], s.name AS [StatName] FROM [sys].[stats] s INNER JOIN [sys].[objects] AS o (NOLOCK) ON o.[object_id] = s.[object_id] INNER JOIN [sys].[tables] AS mst (NOLOCK) ON mst.[object_id] = s.[object_id] INNER JOIN [sys].[schemas] AS t (NOLOCK) ON t.[schema_id] = mst.[schema_id] WHERE (s.name LIKE 'hind_%' OR s.name LIKE '_dta_stat%') AND auto_created = 0 AND s.name NOT IN (SELECT name FROM sys.indexes);"
        }
      }
    ],
    "SQLServerVersion": [
      {
        "type": "CLR",
        "name": "SQLServerVersion",
        "implementation": {
          "class": "Microsoft.SqlServer.Management.Assessment.Probes.ServerVersionProbe"
        }
      }
    ],
    "MissedIndexes": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT RIGHT(i.[statement],LEN(i.[statement])-(LEN(m.[name])+3)) AS [Table], CASE WHEN (i.equality_columns IS NOT NULL AND i.inequality_columns IS NULL) THEN i.equality_columns WHEN (i.equality_columns IS NULL AND i.inequality_columns IS NOT NULL) THEN i.inequality_columns ELSE i.equality_columns+','+i.inequality_columns END AS [KeyCols], ISNULL(i.included_columns,'') AS [IncludedCols],(CONVERT(NUMERIC(19,3),s.user_seeks)+CONVERT(NUMERIC(19,3),s.user_scans))*CONVERT(NUMERIC(19,3),s.avg_total_user_cost)*CONVERT(NUMERIC(19,3),s.avg_user_impact) AS [Score] FROM [sys].[dm_db_missing_index_details] i INNER JOIN [master].[sys].[databases] m ON i.database_id=m.database_id INNER JOIN [sys].[dm_db_missing_index_groups] g ON i.index_handle=g.index_handle INNER JOIN [sys].[dm_db_missing_index_group_stats] s ON s.group_handle=g.index_group_handle WHERE m.[name]=@TargetName"
        }
      }
    ],
    "DatabaseBackups": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT db.recovery_model, db.recovery_model_desc, fb.LastFullBackup, tl.LastTLBackup FROM [master].[sys].[databases] db (NOLOCK) LEFT JOIN (SELECT b.database_name, DATEDIFF(HH, MAX(b.backup_finish_date),GETDATE()) AS LastFullBackup FROM [msdb].[dbo].[backupset] b WHERE b.is_copy_only=0 AND b.type='D' GROUP BY b.database_name) fb ON fb.database_name=db.name LEFT JOIN (SELECT b.database_name, DATEDIFF(HH, MAX(b.backup_finish_date), GETDATE()) AS LastTLBackup FROM [msdb].[dbo].[backupset] b WHERE b.is_copy_only=0 AND b.type='L' GROUP BY b.database_name HAVING MAX(b.backup_finish_date)>=(SELECT MAX(f.backup_finish_date) FROM [msdb].[dbo].[backupset] f WHERE f.is_copy_only=0 AND f.type IN ('D','I') AND f.database_name=b.database_name GROUP BY f.database_name )) tl ON fb.database_name=tl.database_name WHERE db.name=@TargetName;"
        }
      }
    ],
    "TempDBFiles": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT COUNT(DISTINCT size) AS filesizeCount FROM tempdb.sys.database_files WHERE [type] = 0"
        }
      }
    ],
    "ServerInstanceConfiguration": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT (SELECT COUNT(cpu_id) FROM sys.dm_os_schedulers WHERE is_online=1 AND scheduler_id<255 AND parent_node_id<64) AS online_logical_processors,(SELECT COUNT(DISTINCT parent_node_id) FROM sys.dm_os_schedulers WHERE scheduler_id<255 AND parent_node_id<64) AS numa_nodes,(SELECT COUNT(*) FROM (SELECT COUNT(cpu_id) CpuNodeCnt from sys.dm_os_schedulers WHERE is_online=1 AND scheduler_id<255 AND parent_node_id<64 GROUP BY parent_node_id,is_online HAVING COUNT(cpu_id)=1)AS Node_CPU) AS nodes_single_cpu,(SELECT COUNT(cpu_id) FROM sys.dm_os_schedulers WHERE scheduler_id<255 AND parent_node_id<64) AS total_logical_processors,(SELECT [value] FROM sys.configurations (NOLOCK) WHERE name='max degree of parallelism') AS MaxDOP"
        }
      }
    ],
    "DatabaseMasterFiles": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT mf.database_id,dbs.name AS databaseName,[type],physical_name,mf.name AS fileName,size,growth,is_percent_growth FROM [sys].[master_files] AS mf INNER JOIN [sys].databases AS dbs ON mf.database_id=dbs.database_id WHERE mf.database_id=ISNULL(@dbId,mf.database_id) AND [type]=ISNULL(@type,[type])"
        }
      },
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT [type],physical_name,mf.name AS fileName,size,growth,is_percent_growth FROM [sys].[master_files] AS mf INNER JOIN [sys].databases AS dbs ON mf.database_id=dbs.database_id WHERE dbs.name=@TargetName AND [type]=ISNULL(@type,[type]) AND is_percent_growth=ISNULL(@is_percent_growth,is_percent_growth)"
        }
      }
    ],
    "InstantFileInitialization": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "version": "[13.0.4001,)",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises"
        },
        "implementation": {
          "query": "SELECT instant_file_initialization_enabled FROM [sys].[dm_server_services] WHERE servicename LIKE 'SQL Server%' AND servicename NOT LIKE 'SQL Server Agent%' AND servicename NOT LIKE 'SQL Server Launchpad%'"
        }
      },
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT 'N' AS instant_file_initialization_enabled"
        }
      }
    ],
    "IndexesDefinitions": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "version": "[11.0,)",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT i.object_id,QUOTENAME(t.name)+'.'+QUOTENAME(st.name) AS TableName,QUOTENAME(i.name) AS IndexName,QUOTENAME(ac.Name) AS ColumnName,ic.is_included_column,i.is_primary_key,i.filter_definition,i.is_unique,ic.key_ordinal,sty.name AS ColTypeName,CASE sty.name WHEN 'nvarchar' THEN ac.max_length/2 ELSE ac.max_length END AS ColTypeSize,i.fill_factor,i.is_disabled,i.type AS IndexType,index_stat.Hits,index_stat.Reads_Ratio,index_stat.last_user_update FROM [sys].[tables] AS st INNER JOIN [sys].[schemas] AS t ON t.[schema_id]=st.[schema_id] INNER JOIN [sys].[indexes] AS i ON st.[object_id]=i.[object_id] INNER JOIN [sys].[index_columns] AS ic ON i.[object_id]=ic.[object_id] AND i.[index_id]=ic.[index_id] INNER JOIN [sys].[all_columns] AS ac ON st.[object_id]=ac.[object_id] AND ic.[column_id]=ac.[column_id] INNER JOIN [sys].[types] AS sty ON ac.user_type_id=sty.user_type_id LEFT JOIN(SELECT s.object_id,s.index_id,(stat.user_seeks+stat.user_scans+stat.user_lookups) AS [Hits],RTRIM(CONVERT(NVARCHAR(10),CAST(CASE WHEN (stat.user_seeks+stat.user_scans+stat.user_lookups) = 0 THEN 0 ELSE CONVERT(REAL,(stat.user_seeks+stat.user_scans+stat.user_lookups)) * 100/CASE (stat.user_seeks+stat.user_scans+stat.user_lookups+stat.user_updates) WHEN 0 THEN 1 ELSE CONVERT(REAL,(stat.user_seeks+stat.user_scans+stat.user_lookups+stat.user_updates)) END END AS DECIMAL(18,2)))) AS [Reads_Ratio],MAX(stat.last_user_update) AS last_user_update FROM sys.indexes s INNER JOIN sys.dm_db_index_usage_stats stat on stat.object_id = s.object_id and stat.index_id = s.index_id WHERE s.type IN (2,6) AND s.is_primary_key=0 AND s.is_unique_constraint=0 GROUP BY s.object_id,s.index_id,stat.user_seeks,stat.user_scans,stat.user_lookups,stat.user_updates ) index_stat ON index_stat.object_id = i.object_id AND index_stat.index_id = i.index_id WHERE i.type IN (1,2,5,6) AND st.is_ms_shipped=0 AND i.is_unique_constraint=0",
          "transform": {
            "type": "indexDefinition"
          }
        }
      }
    ],
    "UserObjectsCountInMasterDB": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "name": "master",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT sao.name AS [Object_Name] FROM master.sys.all_objects sao INNER JOIN master.sys.schemas ss ON sao.[schema_id] = ss.[schema_id] WHERE sao.is_ms_shipped = 0 AND sao.[type] IN ('AF','FN','P','IF','PC','TF','TR','T','V') ORDER BY sao.name, sao.type_desc;",
          "transform": {
            "type": "aggregate",
            "map": {
              "Object_Name": "join"
            }
          }
        }
      }
    ],
    "Autogrow1GB": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "version": "[13.0.4001,)",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance"
        },
        "implementation": {
          "query": "DECLARE @ifi bit IF ( SELECT instant_file_initialization_enabled FROM sys.dm_server_services WHERE servicename LIKE 'SQL Server%' AND servicename NOT LIKE 'SQL Server Agent%' AND servicename NOT LIKE 'SQL Server Launchpad%' ) = 'Y' SET @ifi = 1; ELSE SET @ifi = 0; SELECT mf.[name] AS FileName FROM [sys].[master_files] AS mf (NOLOCK) INNER JOIN [sys].[databases] as dbs (NOLOCK) ON mf.database_id = dbs.database_id WHERE [type] >= CASE WHEN @ifi = 1 THEN 1 ELSE 0 END  AND [type] < 2  AND ((is_percent_growth = 1 AND ((CONVERT(bigint,size)*8)*growth)/100 > 1048576)  OR (is_percent_growth = 0 AND growth*8 > 1048576)) AND dbs.name = @TargetName",
          "transform": {
            "type": "aggregate",
            "map": {
              "FileName": "join"
            }
          }
        }
      }
    ],
    "CpuIdle": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DECLARE @ts_now bigint; SELECT @ts_now=ms_ticks FROM sys.dm_os_sys_info (NOLOCK); SELECT ISNULL(MIN(SystemIdle),100) AS MinIdle FROM (SELECT AVG(SystemIdle) AS SystemIdle FROM (SELECT record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS SystemIdle, [TIMESTAMP] FROM (SELECT [TIMESTAMP], CONVERT(xml, record) AS record FROM sys.dm_os_ring_buffers (NOLOCK) WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' AND record LIKE '%<SystemHealth>%' AND @ts_now-[TIMESTAMP]<=7200000) AS xrb) AS si GROUP BY (@ts_now-[TIMESTAMP])/600000) AS avg;"
        }
      }
    ],
    "ReplicationErrors": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "IF EXISTS(SELECT * FROM [sys].[databases] WHERE is_distributor = 1) BEGIN DECLARE @dbName sysname, @sqlcmd NVARCHAR(max), @dbId int = 0 DECLARE @resultTbl TABLE(publication sysname) WHILE EXISTS(SELECT * FROM [sys].[databases] WHERE is_distributor = 1 AND database_id > @dbId) BEGIN SELECT TOP(1) @dbId = database_id, @dbName = [name]  FROM [sys].[databases] WHERE is_distributor = 1 AND database_id > @dbId ORDER BY database_id; SET @sqlcmd = N'SELECT ''['+@dbName+'].'' + msa.publication FROM ['+@dbName+'].[dbo].[MSdistribution_history] AS msh  INNER JOIN ['+@dbName+'].[dbo].[MSrepl_errors] AS mse ON mse.id = msh.error_id  INNER JOIN ['+@dbName+'].[dbo].[MSdistribution_agents] AS msa ON msh.agent_id = msa.id WHERE mse.time >= DATEADD(hh, -24, GETDATE()) GROUP BY msa.publication' INSERT INTO @resultTbl EXECUTE sp_executesql @sqlcmd END SELECT * FROM @resultTbl END;",
          "transform": {
            "type": "aggregate",
            "map": {
              "publication": "join"
            }
          }
        }
      }
    ],
    "SysAlerts": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT DISTINCT severity, message_id FROM [msdb].[dbo].[sysalerts]",
          "transform": {
            "type": "aggregate",
            "map": {
              "severity": "array",
              "message_id": "array"
            }
          }
        }
      }
    ],
    "WeakPassword": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DECLARE @word TABLE (word NVARCHAR(50)); INSERT INTO @word values ('0'),('012'),('0123'),('01234'),('012345'),('0123456'),('01234567'),('012345678'),('0123456789'),('01234567890'),('11111'),('111111'),('1111111'),('11111111'),('21'),('321'),('4321'),('54321'),('654321'),('7654321'),('87654321'),('987654321'),('0987654321'),('pwd'),('Password'),('password'),('P@ssw0rd'),('p@ssw0rd'),('Teste'),('teste'),('Test'),('test'),(''),('p@wd'),('Qwerty'),('qwerty'),('Password1'),('password1'); SELECT DISTINCT RTRIM(s.name) AS [PasswordData] FROM @word d INNER JOIN master.sys.sql_logins s ON PWDCOMPARE(d.word, s.[password_hash]) = 1",
          "transform": {
            "type": "aggregate",
            "map": {
              "PasswordData": "join"
            }
          }
        }
      }
    ],
    "VLF": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DBCC LOGINFO (@TargetName) WITH NO_INFOMSGS"
        }
      }
    ],
    "BadNamingSP": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT s.[name]+'.'+so.[name] AS ObjectName FROM sys.objects so  INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] = 'P' AND so.[name] LIKE 'sp[_]%' AND so.[name] NOT IN  ('sp_alterdiagram','sp_creatediagram','sp_dropdiagram','sp_helpdiagramdefinition','sp_helpdiagrams','sp_renamediagram','sp_upgraddiagrams');",
          "transform": {
            "type": "aggregate",
            "map": {
              "ObjectName": "join"
            }
          }
        }
      }
    ],
    "BadNamingSpecialChars": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT s.[name] +'.'+so.[name] as ObjectName FROM sys.objects so  INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] <> 'S' AND (so.[name] LIKE '% %' OR so.[name] LIKE '%[[]%' OR so.[name] LIKE '%]%' OR so.[name] LIKE '%-%' OR so.[name] LIKE '%.%' OR so.[name] LIKE '%,%' OR so.[name] LIKE '%;%' OR so.[name] LIKE '%' + CHAR(34) + '%' OR so.[name] LIKE '%' + CHAR(39) + '%');",
          "transform": {
            "type": "aggregate",
            "map": {
              "ObjectName": "join"
            }
          }
        }
      }
    ],
    "BadNamingSpecialCharsColumns": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT s.name +'.'+ so.name + '.'+sc.name AS ObjectName FROM sys.columns sc  INNER JOIN sys.objects so ON sc.object_id = so.object_id INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND (sc.[name] LIKE '% %' OR sc.[name] LIKE '%[[]%' OR sc.[name] LIKE '%]%' OR sc.[name] LIKE '%-%' OR sc.[name] LIKE '%.%' OR sc.[name] LIKE '%,%' OR sc.[name] LIKE '%;%' OR sc.[name] LIKE '%' + CHAR(34) + '%' OR sc.[name] LIKE '%' + CHAR(39) + '%') ORDER BY 1;",
          "transform": {
            "type": "aggregate",
            "map": {
              "ObjectName": "join"
            }
          }
        }
      }
    ],
    "BadNamingUserFunctions": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT s.name+'.'+so.name AS ObjectName FROM sys.objects so INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] IN ('FN','FS','TF','IF') AND so.[name] LIKE 'fn[_]%' AND so.[name] NOT IN ('fn_diagram_objects')",
          "transform": {
            "type": "aggregate",
            "map": {
              "ObjectName": "join"
            }
          }
        }
      }
    ],
    "BadNamingKeywords": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": [
            "DECLARE @KeywordTbl AS TABLE(Keyword VARCHAR(255)) INSERT INTO @KeywordTbl VALUES ('ABSOLUTE'),('ACTION'),('ADA'),('ADD'),('ADMIN'),('AFTER'),('AGGREGATE'),('ALIAS'),('ALL'),('ALLOCATE'),('ALTER'),('AND'),('ANY'),('ARE'),('ARRAY'),('AS'),('ASC'),('ASSERTION'),('AT'),('AUTHORIZATION'),('AVG'),('BACKUP'),('BEFORE'),('BEGIN'),('BETWEEN'),('BINARY'),('BIT'),('BIT_LENGTH'),('BLOB'),('BOOLEAN'),('BOTH'),('BREADTH'),('BREAK'),('BROWSE'),('BULK'),('BY'),('CALL'),('CASCADE'),('CASCADED'),('CASE'),('CAST'),('CATALOG'),('CHAR'),('CHAR_LENGTH'),('CHARACTER'),('CHARACTER_LENGTH'),('CHECK'),('CHECKPOINT'),('CLASS'),('CLOB'),('CLOSE'),('CLUSTERED'),('COALESCE'),('COLLATE'),('COLLATION'),('COLUMN'),('COMMIT'),('COMPLETION'),('COMPUTE'),('CONNECT'),('CONNECTION'),('CONSTRAINT'),('CONSTRAINTS'),('CONSTRUCTOR'),('CONTAINS'),('CONTAINSTABLE'),('CONTINUE'),('CONVERT'),('CORRESPONDING'),('COUNT'),('CREATE'),('CROSS'),('CUBE'),('CURRENT'),('CURRENT_DATE'),('CURRENT_PATH'),('CURRENT_ROLE'),('CURRENT_TIME'),('CURRENT_TIMESTAMP'),('CURRENT_USER'),('CURSOR'),('CYCLE'),('DATA'),('DATABASE'),('DATE'),('DAY'),('DBCC'),('DEALLOCATE'),('DEC'),('DECIMAL'),('DECLARE'),('DEFAULT'),('DEFERRABLE'),('DEFERRED'),('DELETE'),('DENY'),('DEPTH'),('DEREF'),('DESC'),('DESCRIBE'),('DESCRIPTOR'),('DESTROY'),('DESTRUCTOR'),('DETERMINISTIC'),('DIAGNOSTICS'),('DICTIONARY'),('DISCONNECT'),('DISK'),('DISTINCT'),('DISTRIBUTED'),('DOMAIN'),('DOUBLE'),('DROP'),('DUMMY'),('DUMP'),('DYNAMIC') SELECT [schema]+'.'+[ObjName] AS ObjectName FROM ( SELECT s.name [schema],so.name [ObjName],type,type_desc FROM sys.objects so INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] <> 'S') AS ObjNames CROSS JOIN @KeywordTbl WHERE ObjName like '% '+Keyword+' %' OR ObjName like '% '+Keyword OR ObjName=Keyword",
            "DECLARE @KeywordTbl AS TABLE(Keyword VARCHAR(255)) INSERT INTO @KeywordTbl VALUES ('EACH'),('ELSE'),('END'),('END-EXEC'),('EQUALS'),('ERRLVL'),('ESCAPE'),('EVERY'),('EXCEPT'),('EXCEPTION'),('EXEC'),('EXECUTE'),('EXISTS'),('EXIT'),('EXTERNAL'),('EXTRACT'),('FALSE'),('FETCH'),('FILE'),('FILLFACTOR'),('FIRST'),('FLOAT'),('FOR'),('FOREIGN'),('FORTRAN'),('FOUND'),('FREE'),('FREETEXT'),('FREETEXTTABLE'),('FROM'),('FULL'),('FULLTEXTTABLE'),('FUNCTION'),('GENERAL'),('GET'),('GLOBAL'),('GO'),('GOTO'),('GRANT'),('GROUP'),('GROUPING'),('HAVING'),('HOLDLOCK'),('HOST'),('HOUR'),('IDENTITY'),('IDENTITY_INSERT'),('IDENTITYCOL'),('IF'),('IGNORE'),('IMMEDIATE'),('IN'),('INCLUDE'),('INDEX'),('INDICATOR'),('INITIALIZE'),('INITIALLY'),('INNER'),('INOUT'),('INPUT'),('INSENSITIVE'),('INSERT'),('INT'),('INTEGER'),('INTERSECT'),('INTERVAL'),('INTO'),('IS'),('ISOLATION'),('ITERATE'),('JOIN'),('KEY'),('KILL'),('LANGUAGE'),('LARGE'),('LAST'),('LATERAL'),('LEADING'),('LEFT'),('LESS'),('LEVEL'),('LIKE'),('LIMIT'),('LINENO'),('LOAD'),('LOCAL'),('LOCALTIME'),('LOCALTIMESTAMP'),('LOCATOR'),('LOWER'),('MAP'),('MATCH'),('MAX'),('MIN'),('MINUTE'),('MODIFIES'),('MODIFY'),('MODULE'),('MONTH') SELECT [schema]+'.'+[ObjName] AS ObjectName FROM ( SELECT s.name [schema],so.name [ObjName],type,type_desc FROM sys.objects so  INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] <> 'S') AS ObjNames CROSS JOIN @KeywordTbl WHERE ObjName like '% '+Keyword+' %' OR ObjName like '% '+Keyword OR ObjName=Keyword",
            "DECLARE @KeywordTbl AS TABLE(Keyword VARCHAR(255)) INSERT INTO @KeywordTbl VALUES ('NAMES'),('NATIONAL'),('NATURAL'),('NCHAR'),('NCLOB'),('NEW'),('NEXT'),('NO'),('NOCHECK'),('NONCLUSTERED'),('NONE'),('NOT'),('NULL'),('NULLIF'),('NUMERIC'),('OBJECT'),('OCTET_LENGTH'),('OF'),('OFF'),('OFFSETS'),('OLD'),('ON'),('ONLY'),('OPEN'),('OPENDATASOURCE'),('OPENQUERY'),('OPENROWSET'),('OPENXML'),('OPERATION'),('OPTION'),('OR'),('ORDER'),('ORDINALITY'),('OUT'),('OUTER'),('OUTPUT'),('OVER'),('OVERLAPS'),('PAD'),('PARAMETER'),('PARAMETERS'),('PARTIAL'),('PASCAL'),('PATH'),('PERCENT'),('PLAN'),('POSITION'),('POSTFIX'),('PRECISION'),('PREFIX'),('PREORDER'),('PREPARE'),('PRESERVE'),('PRIMARY'),('PRINT'),('PRIOR'),('PRIVILEGES'),('PROC'),('PROCEDURE'),('PUBLIC'),('RAISERROR'),('READ'),('READS'),('READTEXT'),('REAL'),('RECONFIGURE'),('RECURSIVE'),('REF'),('REFERENCES'),('REFERENCING'),('RELATIVE'),('REPLICATION'),('RESTORE'),('RESTRICT'),('RESULT'),('RETURN'),('RETURNS'),('REVOKE'),('RIGHT'),('ROLE'),('ROLLBACK'),('ROLLUP'),('ROUTINE'),('ROW'),('ROWCOUNT'),('ROWGUIDCOL'),('ROWS'),('RULE') SELECT [schema]+'.'+[ObjName] AS ObjectName FROM ( SELECT s.name [schema],so.name [ObjName],type,type_desc FROM sys.objects so INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] <> 'S') AS ObjNames CROSS JOIN @KeywordTbl WHERE ObjName like '% '+Keyword+' %' OR ObjName like '% '+Keyword OR ObjName=Keyword",
            "DECLARE @KeywordTbl AS TABLE(Keyword VARCHAR(255)) INSERT INTO @KeywordTbl VALUES ('SAVE'),('SAVEPOINT'),('SCHEMA'),('SCOPE'),('SCROLL'),('SEARCH'),('SECOND'),('SECTION'),('SELECT'),('SEQUENCE'),('SESSION'),('SESSION_USER'),('SET'),('SETS'),('SETUSER'),('SHUTDOWN'),('SIZE'),('SMALLINT'),('SOME'),('SPACE'),('SPECIFIC'),('SPECIFICTYPE'),('SQL'),('SQLCA'),('SQLCODE'),('SQLERROR'),('SQLEXCEPTION'),('SQLSTATE'),('SQLWARNING'),('START'),('STATE'),('STATEMENT'),('STATIC'),('STATISTICS'),('STRUCTURE'),('SUBSTRING'),('SUM'),('SYSTEM_USER'),('TABLE'),('TEMPORARY'),('TERMINATE'),('TEXTSIZE'),('THAN'),('THEN'),('TIME'),('TIMESTAMP'),('TIMEZONE_HOUR'),('TIMEZONE_MINUTE'),('TO'),('TOP'),('TRAILING'),('TRAN'),('TRANSACTION'),('TRANSLATE'),('TRANSLATION'),('TREAT'),('TRIGGER'),('TRIM'),('TRUE'),('TRUNCATE'),('UNDER'),('UNION'),('UNIQUE'),('UNKNOWN'),('UNNEST'),('UPDATE'),('UPDATETEXT'),('UPPER'),('USAGE'),('USE'),('USER'),('USING'),('VALUE'),('VALUES'),('VARCHAR'),('VARIABLE'),('VARYING'),('VIEW'),('WAITFOR'),('WHEN'),('WHENEVER'),('WHERE'),('WHILE'),('WITH'),('WITHOUT'),('WORK'),('WRITE'),('WRITETEXT'),('YEAR'),('ZONE') SELECT [schema]+'.'+[ObjName] AS ObjectName FROM ( SELECT s.name [schema],so.name [ObjName],type,type_desc FROM sys.objects so  INNER JOIN sys.schemas s ON so.schema_id = s.schema_id WHERE so.is_ms_shipped = 0 AND [type] <> 'S') AS ObjNames CROSS JOIN @KeywordTbl WHERE ObjName like '% '+Keyword+' %' OR ObjName like '% '+Keyword OR ObjName=Keyword"
          ],
          "transform": {
            "type": "aggregate",
            "map": {
              "ObjectName": "join"
            }
          }
        }
      }
    ],
    "DeprecatedFeaturesSQLModules": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": [
            "IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion/0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('disk init',NULL,9),('disk resize',NULL,9),('for load',NULL,9),('dbcc dbrepair',NULL,9),('dbcc newalloc',NULL,9),('dbcc pintable',NULL,9),('dbcc unpintable',NULL,9),('dbcc rowlock',NULL,9),('dbcc textall',NULL,9),('dbcc textalloc',NULL,9),('*=',NULL,9),('=*',NULL,9),('setuser',9,NULL),('sp_helpdevice',9,NULL),('sp_addtype',9,NULL),('sp_attach_db',9,NULL),('sp_attach_single_file_db',9,NULL),('sp_bindefault',9,NULL),('sp_unbindefault',9,NULL),('sp_bindrule',9,NULL),('sp_unbindrule',9,NULL),('create default',9,NULL),('drop default',9,NULL),('create rule',9,NULL),('drop rule',9,NULL),('sp_renamedb',9,NULL),('sp_resetstatus',9,NULL),('dbcc dbreindex',9,NULL),('dbcc indexdefrag',9,NULL),('dbcc showcontig',9,NULL),('sp_addextendedproc',9,NULL),('sp_dropextendedproc',9,NULL),('sp_helpextendedproc',9,NULL),('xp_loginconfig',1,NULL),('sp_fulltext_catalog',9,NULL),('sp_fulltext_table',9,NULL),('sp_fulltext_column',9,NULL),('sp_fulltext_database',9,NULL),('sp_help_fulltext_tables',9,NULL),('sp_help_fulltext_columns',9,NULL),('sp_help_fulltext_catalogs',9,NULL),('sp_help_fulltext_tables_cursor',9,NULL),('sp_help_fulltext_columns_cursor',9,NULL) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT QUOTENAME(ss.name)+'.'+QUOTENAME(so.name) AS [ObjectName],tk.Keyword FROM sys.sql_modules sm (NOLOCK) INNER JOIN sys.objects so (NOLOCK) ON sm.[object_id]=so.[object_id] INNER JOIN sys.schemas ss (NOLOCK) ON so.[schema_id]=ss.[schema_id] CROSS JOIN @tblKeywords tk WHERE PATINDEX('%' + tk.Keyword + '%',LOWER(sm.[definition]) COLLATE DATABASE_DEFAULT)>1 AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped')=0 END",
            "IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion/0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('sp_help_fulltext_catalogs_cursor',9,NULL),('fn_get_sql',9,NULL),('sp_indexoption',9,NULL),('sp_lock',9,NULL),('indexkey_property',9,NULL),('file_id',9,NULL),('sp_certify_removable',9,NULL),('sp_create_removable',9,NULL),('sp_dbremove',9,NULL),('sp_addapprole',9,NULL),('sp_dropapprole',9,NULL),('sp_addlogin',9,NULL),('sp_droplogin',9,NULL),('sp_adduser',9,NULL),('sp_dropuser',9,NULL),('sp_grantdbaccess',9,NULL),('sp_revokedbaccess',9,NULL),('sp_addrole',9,NULL),('sp_droprole',9,NULL),('sp_approlepassword',9,NULL),('sp_password',9,NULL),('sp_changeobjectowner',9,NULL),('sp_defaultdb',9,NULL),('sp_defaultlanguage',9,NULL),('sp_denylogin',9,NULL),('sp_grantlogin',9,NULL),('sp_revokelogin',9,NULL),('user_id',9,NULL),('sp_srvrolepermission',9,NULL),('sp_dbfixedrolepermission',9,NULL),('text',9,NULL),('ntext',9,NULL),('image',9,NULL),('textptr',9,NULL),('textvalid',9,NULL),('sp_addalias',9,10),('no_log',9,10),('truncate_only',9,10),('backup transaction',9,10),('dbcc concurrencyviolation',9,10),('sp_addgroup',9,10),('sp_changegroup',9,10),('sp_dropgroup',9,10),('sp_helpgroup',9,10),('sp_makewebtask',NULL,10),('sp_dropwebtask',NULL,10),('sp_runwebtask',NULL,10),('sp_enumcodepages',NULL,10),('dump',9,10),('load',9,10),('sp_articlesynctranprocs',NULL,10),('sp_diskdefault',NULL,10),('sp_eventlog',NULL,10) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT QUOTENAME(ss.name)+'.'+QUOTENAME(so.name) AS [ObjectName],tk.Keyword FROM sys.sql_modules sm (NOLOCK) INNER JOIN sys.objects so (NOLOCK) ON sm.[object_id]=so.[object_id] INNER JOIN sys.schemas ss (NOLOCK) ON so.[schema_id]=ss.[schema_id] CROSS JOIN @tblKeywords tk WHERE PATINDEX('%' + tk.Keyword + '%',LOWER(sm.[definition]) COLLATE DATABASE_DEFAULT)>1 AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped')=0 END",
            "IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion/0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('sp_getmbcscharlen',NULL,10),('sp_helplog',NULL,10),('sp_helpsql',NULL,10),('sp_ismbcsleadbyte',NULL,10),('sp_lock2',NULL,10),('sp_msget_current_activity',NULL,10),('sp_msset_current_activity',NULL,10),('sp_msobjessearch',NULL,10),('xp_enum_activescriptengines',NULL,10),('xp_eventlog',NULL,10),('xp_getadmingroupname',NULL,10),('xp_getfiledetails',NULL,10),('xp_getlocalsystemaccountname',NULL,10),('xp_isntadmin',NULL,10),('xp_mslocalsystem',NULL,10),('xp_msnt2000',NULL,10),('xp_msplatform',NULL,10) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT QUOTENAME(ss.name)+'.'+QUOTENAME(so.name) AS [ObjectName],tk.Keyword FROM sys.sql_modules sm (NOLOCK) INNER JOIN sys.objects so (NOLOCK) ON sm.[object_id]=so.[object_id] INNER JOIN sys.schemas ss (NOLOCK) ON so.[schema_id]=ss.[schema_id] CROSS JOIN @tblKeywords tk WHERE PATINDEX('%' + tk.Keyword + '%',LOWER(sm.[definition]) COLLATE DATABASE_DEFAULT)>1 AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped')=0 END",
            "IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion/0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('xp_setsecurity',NULL,10),('xp_varbintohexstr',NULL,10),('spt_datatype_info',NULL,10),('spt_datatype_info_ext',NULL,10),('spt_provider_types',NULL,10),('spt_server_info',NULL,10),('spt_values',NULL,10),('sysfulltextnotify ',NULL,10),('syslocks',NULL,10),('sysproperties',NULL,10),('sysprotects_aux',NULL,10),('sysprotects_view',NULL,10),('sysremote_catalogs',NULL,10),('sysremote_column_privileges',NULL,10),('sysremote_columns',NULL,10),('sysremote_foreign_keys',NULL,10) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT QUOTENAME(ss.name)+'.'+QUOTENAME(so.name) AS [ObjectName],tk.Keyword FROM sys.sql_modules sm (NOLOCK) INNER JOIN sys.objects so (NOLOCK) ON sm.[object_id]=so.[object_id] INNER JOIN sys.schemas ss (NOLOCK) ON so.[schema_id]=ss.[schema_id] CROSS JOIN @tblKeywords tk WHERE PATINDEX('%' + tk.Keyword + '%',LOWER(sm.[definition]) COLLATE DATABASE_DEFAULT)>1 AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped')=0 END",
            "IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion/0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('sysremote_indexes',NULL,10),('sysremote_primary_keys',NULL,10),('sysremote_provider_types',NULL,10),('sysremote_schemata',NULL,10),('sysremote_statistics',NULL,10),('sysremote_table_privileges',NULL,10),('sysremote_tables',NULL,10),('sysremote_views',NULL,10),('syssegments',NULL,10),('sysxlogins',NULL,10),('sp_droptype',10,NULL),('@@remserver',10,NULL),('remote_proc_transactions',10,NULL),('sp_addumpdevice',10,NULL),('xp_grantlogin',10,NULL),('xp_revokelogin',10,NULL),('grant all',10,NULL),('deny all',10,NULL),('revoke all',10,NULL),('fn_virtualservernodes',10,NULL),('fn_servershareddrives',10,NULL),('writetext',10,NULL),('updatetext',10,NULL),('readtext',10,NULL),('torn_page_detection',10,NULL),('set rowcount',10,NULL),('dbo_only',9,11) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT QUOTENAME(ss.name)+'.'+QUOTENAME(so.name) AS [ObjectName],tk.Keyword FROM sys.sql_modules sm (NOLOCK) INNER JOIN sys.objects so (NOLOCK) ON sm.[object_id]=so.[object_id] INNER JOIN sys.schemas ss (NOLOCK) ON so.[schema_id]=ss.[schema_id] CROSS JOIN @tblKeywords tk WHERE PATINDEX('%' + tk.Keyword + '%',LOWER(sm.[definition]) COLLATE DATABASE_DEFAULT)>1 AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped')=0 END",
            "IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion/0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('mediapassword',9,11 ),('password',9,11 ),('with append',10,11),('sp_dboption',9,11),('databaseproperty',9,11),('fastfirstrow',10,11),('sp_addserver',10,11 ),('sp_dropalias',9,11),('disable_def_cnst_chk',10,11),('sp_activedirectory_obj',NULL,11),('sp_activedirectory_scp',NULL,11),('sp_activedirectory_start',NULL,11),('sys.database_principal_aliases',NULL,11),('compute',10,11),('compute by',10,11),('sp_change_users_login',11,NULL),('sp_depends',11,NULL),('sp_getbindtoken',11,NULL),('sp_bindsession',11,NULL),('fmtonly',11,NULL),('raiserror',11,NULL),('sp_db_increased_partitions',11,NULL),('databasepropertyex(''isfulltextenabled'')',11,NULL),('sp_dbcmptlevel',11,NULL),('set ansi_nulls off',11,NULL),('set ansi_padding off',11,NULL),('set concat_null_yields_null off',11,NULL),('set offsets',11,NULL),('sys.numbered_procedures',12,NULL),('sys.numbered_procedure_parameters',12,NULL),('sys.sql_dependencies',12,NULL),('sp_db_vardecimal_storage_format',12,NULL),('sp_estimated_rowsize_reduction_for_vardecimal',12,NULL),('sp_trace_create',12,NULL),('sp_trace_setevent',12,NULL),('sp_trace_setstatus',12,NULL),('fn_trace_geteventinfo',12,NULL),('fn_trace_getfilterinfo',12,NULL),('fn_trace_gettable',12,NULL),('sys.traces',12,NULL),('sys.trace_events',12,NULL),('sys.trace_event_bindings',12,NULL),('sys.trace_categories',12,NULL),('sys.trace_columns',12,NULL),('sys.trace_subclass_values',12,NULL),('disable_interleaved_execution_tvf',10,15),('disable_batch_mode_memory_grant_feedback',10,15),('disable_batch_mode_adaptive_joins',10,15) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT QUOTENAME(ss.name)+'.'+QUOTENAME(so.name) AS [ObjectName],tk.Keyword FROM sys.sql_modules sm (NOLOCK) INNER JOIN sys.objects so (NOLOCK) ON sm.[object_id]=so.[object_id] INNER JOIN sys.schemas ss (NOLOCK) ON so.[schema_id]=ss.[schema_id] CROSS JOIN @tblKeywords tk WHERE PATINDEX('%' + tk.Keyword + '%',LOWER(sm.[definition]) COLLATE DATABASE_DEFAULT)>1 AND OBJECTPROPERTY(sm.[object_id],'IsMSShipped')=0 END"
          ],
          "transform": {
            "type": "aggregate",
            "group": "ObjectName",
            "map": {
              "Keyword": "join"
            }
          }
        }
      }
    ],
    "DeprecatedFeaturesJobs": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": [
            "USE [msdb]; IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion / 0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('disk init',NULL,9),('disk resize',NULL,9),('for load',NULL,9),('dbcc dbrepair',NULL,9),('dbcc newalloc',NULL,9),('dbcc pintable',NULL,9),('dbcc unpintable',NULL,9),('dbcc rowlock',NULL,9),('dbcc textall',NULL,9),('dbcc textalloc',NULL,9),('*=',NULL,9),('=*',NULL,9),('setuser',9,NULL),('sp_helpdevice',9,NULL),('sp_addtype',9,NULL),('sp_attach_db',9,NULL),('sp_attach_single_file_db',9,NULL),('sp_bindefault',9,NULL),('sp_unbindefault',9,NULL),('sp_bindrule',9,NULL),('sp_unbindrule',9,NULL),('create default',9,NULL),('drop default',9,NULL),('create rule',9,NULL),('drop rule',9,NULL),('sp_renamedb',9,NULL),('sp_resetstatus',9,NULL),('dbcc dbreindex',9,NULL),('dbcc indexdefrag',9,NULL),('dbcc showcontig',9,NULL),('sp_addextendedproc',9,NULL),('sp_dropextendedproc',9,NULL),('sp_helpextendedproc',9,NULL),('xp_loginconfig',1,NULL),('sp_fulltext_catalog',9,NULL),('sp_fulltext_table',9,NULL),('sp_fulltext_column',9,NULL),('sp_fulltext_database',9,NULL),('sp_help_fulltext_tables',9,NULL),('sp_help_fulltext_columns',9,NULL),('sp_help_fulltext_catalogs',9,NULL),('sp_help_fulltext_tables_cursor',9,NULL),('sp_help_fulltext_columns_cursor',9,NULL) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT 'Job: '+sj.[name]+' Step: '+sjs.step_name AS ObjectName,Keyword FROM msdb.dbo.sysjobsteps sjs (NOLOCK) INNER JOIN msdb.dbo.sysjobs sj (NOLOCK) ON sjs.job_id=sj.job_id CROSS JOIN @tblKeywords tk WHERE PATINDEX('%'+tk.Keyword+'%',LOWER(sjs.[command]) COLLATE DATABASE_DEFAULT)>1 AND sjs.[subsystem] IN ('TSQL','PowerShell'); END",
            "USE [msdb]; IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion / 0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('sp_help_fulltext_catalogs_cursor',9,NULL),('fn_get_sql',9,NULL),('sp_indexoption',9,NULL),('sp_lock',9,NULL),('indexkey_property',9,NULL),('file_id',9,NULL),('sp_certify_removable',9,NULL),('sp_create_removable',9,NULL),('sp_dbremove',9,NULL),('sp_addapprole',9,NULL),('sp_dropapprole',9,NULL),('sp_addlogin',9,NULL),('sp_droplogin',9,NULL),('sp_adduser',9,NULL),('sp_dropuser',9,NULL),('sp_grantdbaccess',9,NULL),('sp_revokedbaccess',9,NULL),('sp_addrole',9,NULL),('sp_droprole',9,NULL),('sp_approlepassword',9,NULL),('sp_password',9,NULL),('sp_changeobjectowner',9,NULL),('sp_defaultdb',9,NULL),('sp_defaultlanguage',9,NULL),('sp_denylogin',9,NULL),('sp_grantlogin',9,NULL),('sp_revokelogin',9,NULL),('user_id',9,NULL),('sp_srvrolepermission',9,NULL),('sp_dbfixedrolepermission',9,NULL),('text',9,NULL),('ntext',9,NULL),('image',9,NULL),('textptr',9,NULL),('textvalid',9,NULL),('sp_addalias',9,10),('no_log',9,10),('truncate_only',9,10),('backup transaction',9,10),('dbcc concurrencyviolation',9,10),('sp_addgroup',9,10),('sp_changegroup',9,10),('sp_dropgroup',9,10),('sp_helpgroup',9,10),('sp_makewebtask',NULL,10),('sp_dropwebtask',NULL,10),('sp_runwebtask',NULL,10),('sp_enumcodepages',NULL,10),('dump',9,10),('load',9,10),('sp_articlesynctranprocs',NULL,10),('sp_diskdefault',NULL,10),('sp_eventlog',NULL,10) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT 'Job: '+sj.[name]+' Step: '+sjs.step_name AS ObjectName,Keyword FROM msdb.dbo.sysjobsteps sjs (NOLOCK) INNER JOIN msdb.dbo.sysjobs sj (NOLOCK) ON sjs.job_id=sj.job_id CROSS JOIN @tblKeywords tk WHERE PATINDEX('%'+tk.Keyword+'%',LOWER(sjs.[command]) COLLATE DATABASE_DEFAULT)>1 AND sjs.[subsystem] IN ('TSQL','PowerShell'); END",
            "USE [msdb]; IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion / 0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('sp_getmbcscharlen',NULL,10),('sp_helplog',NULL,10),('sp_helpsql',NULL,10),('sp_ismbcsleadbyte',NULL,10),('sp_lock2',NULL,10),('sp_msget_current_activity',NULL,10),('sp_msset_current_activity',NULL,10),('sp_msobjessearch',NULL,10),('xp_enum_activescriptengines',NULL,10),('xp_eventlog',NULL,10),('xp_getadmingroupname',NULL,10),('xp_getfiledetails',NULL,10),('xp_getlocalsystemaccountname',NULL,10),('xp_isntadmin',NULL,10),('xp_mslocalsystem',NULL,10),('xp_msnt2000',NULL,10),('xp_msplatform',NULL,10) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT 'Job: '+sj.[name]+' Step: '+sjs.step_name AS ObjectName,Keyword FROM msdb.dbo.sysjobsteps sjs (NOLOCK) INNER JOIN msdb.dbo.sysjobs sj (NOLOCK) ON sjs.job_id=sj.job_id CROSS JOIN @tblKeywords tk WHERE PATINDEX('%'+tk.Keyword+'%',LOWER(sjs.[command]) COLLATE DATABASE_DEFAULT)>1 AND sjs.[subsystem] IN ('TSQL','PowerShell'); END",
            "USE [msdb]; IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion / 0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('xp_setsecurity',NULL,10),('xp_varbintohexstr',NULL,10),('spt_datatype_info',NULL,10),('spt_datatype_info_ext',NULL,10),('spt_provider_types',NULL,10),('spt_server_info',NULL,10),('spt_values',NULL,10),('sysfulltextnotify ',NULL,10),('syslocks',NULL,10),('sysproperties',NULL,10),('sysprotects_aux',NULL,10),('sysprotects_view',NULL,10),('sysremote_catalogs',NULL,10),('sysremote_column_privileges',NULL,10),('sysremote_columns',NULL,10),('sysremote_foreign_keys',NULL,10) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT 'Job: '+sj.[name]+' Step: '+sjs.step_name AS ObjectName,Keyword FROM msdb.dbo.sysjobsteps sjs (NOLOCK) INNER JOIN msdb.dbo.sysjobs sj (NOLOCK) ON sjs.job_id=sj.job_id CROSS JOIN @tblKeywords tk WHERE PATINDEX('%'+tk.Keyword+'%',LOWER(sjs.[command]) COLLATE DATABASE_DEFAULT)>1 AND sjs.[subsystem] IN ('TSQL','PowerShell'); END",
            "USE [msdb]; IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion / 0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('sysremote_indexes',NULL,10),('sysremote_primary_keys',NULL,10),('sysremote_provider_types',NULL,10),('sysremote_schemata',NULL,10),('sysremote_statistics',NULL,10),('sysremote_table_privileges',NULL,10),('sysremote_tables',NULL,10),('sysremote_views',NULL,10),('syssegments',NULL,10),('sysxlogins',NULL,10),('sp_droptype',10,NULL),('@@remserver',10,NULL),('remote_proc_transactions',10,NULL),('sp_addumpdevice',10,NULL),('xp_grantlogin',10,NULL),('xp_revokelogin',10,NULL),('grant all',10,NULL),('deny all',10,NULL),('revoke all',10,NULL),('fn_virtualservernodes',10,NULL),('fn_servershareddrives',10,NULL),('writetext',10,NULL),('updatetext',10,NULL),('readtext',10,NULL),('torn_page_detection',10,NULL),('set rowcount',10,NULL),('dbo_only',9,11 ) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT 'Job: '+sj.[name]+' Step: '+sjs.step_name AS ObjectName,Keyword FROM msdb.dbo.sysjobsteps sjs (NOLOCK) INNER JOIN msdb.dbo.sysjobs sj (NOLOCK) ON sjs.job_id=sj.job_id CROSS JOIN @tblKeywords tk WHERE PATINDEX('%'+tk.Keyword+'%',LOWER(sjs.[command]) COLLATE DATABASE_DEFAULT)>1 AND sjs.[subsystem] IN ('TSQL','PowerShell'); END",
            "USE [msdb]; IF (SELECT COUNT(instance_name) FROM sys.dm_os_performance_counters WHERE [object_name] LIKE '%Deprecated Features%' AND cntr_value>0)>0 BEGIN DECLARE @sqlmajorver INT; SELECT @sqlmajorver=CONVERT(int,(@@microsoftversion / 0x1000000) & 0xff); DECLARE @tblKeywords as TABLE (KeywordID int IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(64), DeprecatedIn tinyint, DiscontinuedIn tinyint) INSERT INTO @tblKeywords VALUES ('mediapassword',9,11 ),('password',9,11 ),('with append',10,11),('sp_dboption',9,11),('databaseproperty',9,11),('fastfirstrow',10,11),('sp_addserver',10,11 ),('sp_dropalias',9,11),('disable_def_cnst_chk',10,11),('sp_activedirectory_obj',NULL,11),('sp_activedirectory_scp',NULL,11),('sp_activedirectory_start',NULL,11),('sys.database_principal_aliases',NULL,11),('compute',10,11),('compute by',10,11),('sp_change_users_login',11,NULL),('sp_depends',11,NULL),('sp_getbindtoken',11,NULL),('sp_bindsession',11,NULL),('fmtonly',11,NULL),('raiserror',11,NULL),('sp_db_increased_partitions',11,NULL),('databasepropertyex(''isfulltextenabled'')',11,NULL),('sp_dbcmptlevel',11,NULL),('set ansi_nulls off',11,NULL),('set ansi_padding off',11,NULL),('set concat_null_yields_null off',11,NULL),('set offsets',11,NULL),('sys.numbered_procedures',12,NULL),('sys.numbered_procedure_parameters',12,NULL),('sys.sql_dependencies',12,NULL),('sp_db_vardecimal_storage_format',12,NULL),('sp_estimated_rowsize_reduction_for_vardecimal',12,NULL),('sp_trace_create',12,NULL),('sp_trace_setevent',12,NULL),('sp_trace_setstatus',12,NULL),('fn_trace_geteventinfo',12,NULL),('fn_trace_getfilterinfo',12,NULL),('fn_trace_gettable',12,NULL),('sys.traces',12,NULL),('sys.trace_events',12,NULL),('sys.trace_event_bindings',12,NULL),('sys.trace_categories',12,NULL),('sys.trace_columns',12,NULL),('sys.trace_subclass_values',12,NULL),('sp_addremotelogin',10,14),('sp_dropremotelogin',10,14),('sp_helpremotelogin',10,14),('sp_remoteoption',10,14) DELETE FROM @tblKeywords WHERE DeprecatedIn>@sqlmajorver OR DiscontinuedIn>@sqlmajorver SELECT 'Job: '+sj.[name]+' Step: '+sjs.step_name AS ObjectName,Keyword FROM msdb.dbo.sysjobsteps sjs (NOLOCK) INNER JOIN msdb.dbo.sysjobs sj (NOLOCK) ON sjs.job_id=sj.job_id CROSS JOIN @tblKeywords tk WHERE PATINDEX('%'+tk.Keyword+'%',LOWER(sjs.[command]) COLLATE DATABASE_DEFAULT)>1 AND sjs.[subsystem] IN ('TSQL','PowerShell'); END"
          ],
          "transform": {
            "type": "aggregate",
            "group": "ObjectName",
            "map": {
              "Keyword": "join"
            }
          }
        }
      }
    ],
    "AffinityNUMANodeNoAssignedCPUs": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": "Windows",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "WITH cpuCTE (node, afin) AS (SELECT DISTINCT(parent_node_id), is_online FROM sys.dm_os_schedulers WHERE scheduler_id < 255 AND parent_node_id < 64 GROUP BY parent_node_id, is_online) SELECT COUNT(DISTINCT(node)) AS NodeCnt FROM cpuCTE WHERE afin = 0 AND node NOT IN ( SELECT DISTINCT(node) FROM cpuCTE WHERE afin = 1)"
        }
      }
    ],
    "IndexesGuidKeyColumns": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT ss.[name]+'.'+t.[name]+'.'+i.[name] as IndexName FROM [sys].[indexes] AS i INNER JOIN [sys].[tables] AS t ON t.[object_id]=i.[object_id] INNER JOIN [sys].[schemas] ss ON ss.[schema_id]=t.[schema_id] INNER JOIN [sys].[index_columns] AS sic ON sic.[object_id]=t.[object_id] AND sic.index_id=i.index_id INNER JOIN [sys].[columns] AS sc ON sc.[object_id]=t.[object_id] AND sc.column_id=sic.column_id INNER JOIN [sys].[types] AS sty ON sc.user_type_id=sty.user_type_id WHERE sic.is_included_column=0 AND sty.name='uniqueidentifier' and i.type=1 AND i.is_unique_constraint=0 AND t.is_ms_shipped=0 GROUP BY ss.name,t.[name],i.name HAVING COUNT(sty.name)>0",
          "transform": {
            "type": "aggregate",
            "map": {
              "IndexName": "join"
            }
          }
        }
      }
    ],
    "SuspectPagesValidation": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "IF (SELECT COUNT(*) FROM msdb.dbo.suspect_pages WHERE (event_type = 1 OR event_type = 2 OR event_type = 3)) > 0 BEGIN SELECT CASE event_type WHEN 1 THEN 'Error 823 or unspecified Error 824' WHEN 2 THEN 'Bad Checksum' WHEN 3 THEN 'Torn Page' ELSE NULL END AS [EventType] FROM msdb.dbo.suspect_pages (NOLOCK) WHERE (event_type = 1 OR event_type = 2 OR event_type = 3) AND DB_NAME(database_id)=(@TargetName) END;"
        }
      }
    ],
    "SparseFilesValidation": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "IF (SELECT COUNT(sd.database_id) FROM sys.databases sd INNER JOIN sys.master_files smf ON sd.database_id = smf.database_id WHERE sd.source_database_id IS NULL AND smf.is_sparse = 1) > 0 BEGIN SELECT 'Database_checks' AS [Category], 'DB_nonSnap_Sparse' AS [Information], DB_NAME(sd.database_id) AS database_name, smf.name AS [SparseFiles], smf.physical_name FROM sys.databases sd INNER JOIN sys.master_files smf ON sd.database_id = smf.database_id WHERE sd.source_database_id IS NULL AND smf.is_sparse = 1 AND DB_NAME(sd.database_id)=@TargetName END;"
        }
      }
    ],
    "TableIndexes": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT s.name+'.'+t.name AS TableName, COUNT(si.index_id) AS IndexCount, MIN(si.index_id) AS MinIndexId, MAX(si.index_id) AS MaxIndexId FROM sys.indexes AS si (NOLOCK) INNER JOIN sys.tables AS t (NOLOCK) ON si.[object_id]=t.[object_id] INNER JOIN sys.schemas AS s (NOLOCK) ON s.[schema_id]=t.[schema_id] WHERE si.is_hypothetical=0 GROUP BY s.name,t.name"
        }
      }
    ],
    "TableIndexesPartitioned": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT DISTINCT s.name+'.'+t.name AS TableName, i.name AS IndexName FROM sys.tables AS t (NOLOCK) INNER JOIN sys.indexes AS i (NOLOCK) ON t.[object_id]=i.[object_id] INNER JOIN sys.data_spaces AS ds (NOLOCK) ON ds.data_space_id=i.data_space_id INNER JOIN sys.schemas AS s (NOLOCK) ON s.[schema_id]=t.[schema_id] WHERE t.[type]='U' AND i.[type] IN (1,2) AND i.is_hypothetical=0 AND t.name IN(SELECT ob.name FROM sys.tables AS ob (NOLOCK) INNER JOIN sys.indexes AS ind (NOLOCK) ON ind.[object_id]=ob.[object_id] INNER JOIN sys.data_spaces AS sds (NOLOCK) ON sds.data_space_id=ind.data_space_id WHERE sds.[type]='PS' GROUP BY ob.name) AND ds.[type]<>'PS'"
        }
      }
    ],
    "NullPassword": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT RTRIM(name) AS [PasswordData] FROM master.sys.sql_logins WHERE [password_hash] IS NULL AND name NOT IN ('MSCRMSqlClrLogin','##MS_SmoExtendedSigningCertificate##','##MS_PolicySigningCertificate##','##MS_SQLResourceSigningCertificate##','##MS_SQLReplicationSigningCertificate##','##MS_SQLAuthenticatorCertificate##','##MS_AgentSigningCertificate##','##MS_SQLEnableSystemAssemblyLoadingUser##')",
          "transform": {
            "type": "aggregate",
            "map": {
              "PasswordData": "join"
            }
          }
        }
      }
    ],
    "NamePassword": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "engineEdition": "OnPremises, ManagedInstance",
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT DISTINCT RTRIM(s.name) AS [PasswordData] FROM master.sys.sql_logins s WHERE PWDCOMPARE(RTRIM(RTRIM(s.name)), s.[password_hash]) = 1",
          "transform": {
            "type": "aggregate",
            "map": {
              "PasswordData": "join"
            }
          }
        }
      }
    ],
    "SystemHealth": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id]=OBJECT_ID('tempdb.dbo.#SystemHealthSessionData')) DROP TABLE #SystemHealthSessionData; IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id]=OBJECT_ID('tempdb.dbo.#SystemHealthSessionData')) CREATE TABLE #SystemHealthSessionData (target_data XML); INSERT INTO #SystemHealthSessionData SELECT CAST(xet.target_data AS XML) FROM sys.dm_xe_session_targets xet INNER JOIN sys.dm_xe_sessions xe ON xe.address=xet.event_session_address WHERE xe.name='system_health' IF (SELECT COUNT(*) FROM #SystemHealthSessionData a WHERE CONVERT(VARCHAR(max), target_data) LIKE '%error_reported%')>0 BEGIN ;WITH cteHealthSession (EventXML) AS (SELECT C.query('.') EventXML FROM #SystemHealthSessionData a CROSS APPLY a.target_data.nodes('/RingBufferTarget/event') AS T(C)),cteErrorReported (EventTime, ErrorNumber) AS (SELECT EventXML.value('(/event/@timestamp)[1]','datetime') AS EventTime,EventXML.value('(/event/data[@name=''error_number'']/value)[1]','int') AS ErrorNumber FROM cteHealthSession WHERE EventXML.value('(/event/@name)[1]','VARCHAR(500)')='error_reported') SELECT ErrorNumber AS [Error_Number], DATEDIFF(hour,MAX(EventTime),GETUTCDATE()) AS [Last_Logged_Days_Ago],COUNT(ErrorNumber) AS Error_Count FROM cteErrorReported a INNER JOIN sys.messages b ON a.ErrorNumber=b.message_id WHERE b.language_id=1033 GROUP BY a.ErrorNumber, b.[text] END"
        }
      }
    ],
    "CompatibilityLevel": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT compatibility_level as [CompatibilityLevel] FROM sys.databases where name=@TargetName"
        }
      }
    ],
    "PendingIORequests": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DECLARE @IOCnt INT SET @IOCnt=1 WHILE @IOCnt<5 BEGIN IF EXISTS(SELECT * FROM sys.dm_io_pending_io_requests WHERE io_type=@io_type) BREAK; WAITFOR DELAY '00:00:01' SET @IOCnt=@IOCnt+1 END; IF @IOCnt<5 SELECT 1"
        }
      }
    ],
    "DBMetaInfo": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DBCC DBINFO(@TargetName) WITH TABLERESULTS,NO_INFOMSGS",
          "transform": {
            "type": "dbInfo"
          }
        }
      }
    ],
    "StatSamplingRate": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "SELECT CONCAT( sh.[name], '.', o.[name] ) AS FullName, CAST(sp.rows_sampled/(sp.[rows]*1.00) AS DECIMAL(5,2)) AS stat_sampling_rate FROM sys.objects AS o INNER JOIN sys.tables AS mst ON mst.[object_id] = o.[object_id] INNER JOIN sys.stats AS ss ON ss.[object_id] = o.[object_id] INNER JOIN sys.schemas AS sh ON sh.[schema_id] = o.[schema_id] CROSS APPLY sys.dm_db_stats_properties(o.[object_id], ss.[stats_id]) AS sp WHERE sp.[rows] > 0 AND sp.rows_sampled/(sp.[rows]*1.00) < @threshold"
        }
      }
    ],
    "IndexStatistics": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,12.0)"
        },
        "implementation": {
           "useDatabase": true, 
           "query": "SELECT CASE si.type WHEN 0 THEN CONCAT(t.[name],'.',mst.[name],' (HEAP)') ELSE CONCAT(t.[name],'.',mst.[name],'.',si.name) END AS IndexFullName,index_stat.fragmentation,index_stat.page_count,si.type AS IndexType FROM sys.indexes si INNER JOIN sys.partitions sp ON si.[object_id]=sp.[object_id] AND si.index_id=sp.index_id INNER JOIN sys.tables AS mst ON mst.[object_id]=si.[object_id] INNER JOIN sys.schemas AS t ON t.[schema_id]=mst.[schema_id] LEFT JOIN (SELECT ps.database_id,ps.[object_id],ps.index_id,ps.partition_number,SUM(ps.avg_fragmentation_in_percent) AS fragmentation,SUM(ps.page_count) [page_count] FROM sys.dm_db_index_physical_stats(DB_ID(@TargetName),NULL,NULL,NULL,NULL) ps WHERE ps.index_level=0 AND ps.alloc_unit_type_desc='IN_ROW_DATA' GROUP BY ps.database_id,ps.[object_id],ps.index_id,ps.partition_number,ps.record_count,ps.forwarded_record_count) index_stat on index_stat.[object_id]=si.[object_id] AND index_stat.index_id=si.index_id AND index_stat.[partition_number]=sp.partition_number WHERE mst.is_ms_shipped=0 AND si.[type] IN (0,1,2)"
        }
      },
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[12.0,)"
        },
        "implementation": {
          "useDatabase": true, 
          "query": "SELECT CASE si.type WHEN 0 THEN CONCAT(t.[name],'.',mst.[name],' (HEAP)') ELSE CONCAT(t.[name],'.',mst.[name],'.',si.name) END AS IndexFullName,ISNULL(index_stat.fragmentation,0) AS fragmentation, ISNULL(index_stat.page_count,0) AS page_count,index_stat_ci.fragmentation_CI,index_stat_ci.state,si.type AS IndexType FROM sys.indexes si INNER JOIN sys.partitions sp ON si.[object_id]=sp.[object_id] AND si.index_id=sp.index_id INNER JOIN sys.tables AS mst ON mst.[object_id]=si.[object_id] INNER JOIN sys.schemas AS t ON t.[schema_id]=mst.[schema_id] LEFT JOIN (SELECT ps.database_id,ps.[object_id],ps.index_id,ps.partition_number,SUM(ps.avg_fragmentation_in_percent) AS fragmentation,SUM(ps.page_count) [page_count] FROM sys.dm_db_index_physical_stats(DB_ID(@TargetName),NULL,NULL,NULL,NULL) ps WHERE ps.index_level=0 AND ps.alloc_unit_type_desc='IN_ROW_DATA' GROUP BY ps.database_id,ps.[object_id],ps.index_id,ps.partition_number,ps.record_count,ps.forwarded_record_count) index_stat on index_stat.[object_id]=si.[object_id] AND index_stat.index_id=si.index_id AND index_stat.[partition_number]=sp.partition_number LEFT JOIN (SELECT rg.object_id,rg.index_id,rg.partition_number,SUM((ISNULL(rg.deleted_rows,1)*100)/CASE WHEN rg.total_rows=0 THEN 1 ELSE rg.total_rows END) AS [fragmentation_CI],rg.[state] FROM sys.column_store_row_groups rg GROUP BY rg.object_id,rg.index_id,rg.partition_number,rg.total_rows,rg.delta_store_hobt_id,rg.row_group_id,rg.state) index_stat_ci on index_stat_ci.[object_id]=si.[object_id] AND index_stat_ci.index_id=si.index_id AND index_stat_ci.[partition_number]=sp.[partition_number] WHERE mst.is_ms_shipped=0 AND si.[type] IN (0,1,2,5,6,7)"
        }
      }
    ],
    
    "XTPIndexHashStatistics": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[12.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "IF NOT EXISTS(SELECT * FROM sys.filegroups where [type]='FX') RETURN; DECLARE @tmpXIS TABLE([object_id] int,[schema_name] VARCHAR(100) COLLATE database_default,[table_name] VARCHAR(300) COLLATE database_default,[index_id] int,[index_name] VARCHAR(300) COLLATE database_default,total_bucket_count bigint,empty_bucket_count bigint,avg_chain_length bigint,max_chain_length bigint, KeyCols VARCHAR(4000) COLLATE database_default,DistinctCnt bigint NULL,isdone bit) INSERT INTO @tmpXIS SELECT xis.[object_id],t.name,o.name,xis.index_id,si.name,xhis.total_bucket_count,xhis.empty_bucket_count,xhis.avg_chain_length,xhis.max_chain_length,SUBSTRING((SELECT ','+ac.name FROM sys.tables AS st INNER JOIN sys.indexes AS i ON st.[object_id]=i.[object_id] INNER JOIN sys.index_columns AS ic ON i.[object_id]=ic.[object_id] AND i.[index_id]=ic.[index_id] INNER JOIN sys.all_columns AS ac ON st.[object_id]=ac.[object_id] AND ic.[column_id]=ac.[column_id] WHERE si.[object_id]=i.[object_id] AND si.index_id=i.index_id AND ic.is_included_column=0 ORDER BY ic.key_ordinal FOR XML PATH('')),2,8000) AS KeyCols,NULL distinctCntOUT,0 FROM sys.dm_db_xtp_hash_index_stats AS xhis INNER JOIN sys.dm_db_xtp_index_stats AS xis ON xis.[object_id]=xhis.[object_id] AND xis.[index_id]=xhis.[index_id] INNER JOIN sys.indexes AS si (NOLOCK) ON xis.[object_id]=si.[object_id] AND xis.[index_id]=si.[index_id] INNER JOIN sys.objects AS o (NOLOCK) ON si.[object_id]=o.[object_id] INNER JOIN sys.tables AS mst (NOLOCK) ON mst.[object_id]=o.[object_id] INNER JOIN sys.schemas AS t (NOLOCK) ON t.[schema_id]=mst.[schema_id] WHERE o.[type]='U' DECLARE @objectid int,@indexid int,@sqlcmd NVARCHAR(4000),@params NVARCHAR(500),@schema_name VARCHAR(100),@table_name VARCHAR(300),@KeyCols VARCHAR(4000),@distinctCnt bigint IF EXISTS (SELECT TOP 1 [object_id] FROM @tmpXIS WHERE isdone=0) BEGIN WHILE (SELECT COUNT([object_id]) FROM @tmpXIS WHERE isdone=0)>0 BEGIN SELECT TOP 1 @objectid=[object_id],@indexid=[index_id],@schema_name=[schema_name],@table_name=[table_name],@KeyCols=KeyCols FROM @tmpXIS WHERE isdone=0 SELECT @sqlcmd='SELECT @distinctCntOUT=COUNT(*) FROM (SELECT DISTINCT '+@KeyCols+' FROM '+@schema_name+'.'+@table_name+') t1;' EXECUTE sp_executesql @sqlcmd,N'@distinctCntOUT bigint OUTPUT',@distinctCntOUT=@distinctCnt OUTPUT UPDATE @tmpXIS SET DistinctCnt=@distinctCnt,isdone=1 WHERE [object_id]=@objectid AND [index_id]=@indexid; END; END; SELECT CONCAT([schema_name],'.',table_name,'.',index_name) AS IndexFullName,FLOOR((CAST(empty_bucket_count AS FLOAT)/total_bucket_count)*100) EmptyBucketPct,total_bucket_count,avg_chain_length,DistinctCnt FROM @tmpXIS"
        }
      }
    ],
    "XTPNonClusteredIndexHashStatistics": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[12.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT DISTINCT CONCAT(t.name,'.',o.name,'.',si.name) AS IndexFullName,FLOOR((CAST(page_update_retry_count AS FLOAT)/CASE WHEN page_update_count=0 THEN 1 ELSE page_update_count END)*100) AS page_update_count_pct,FLOOR((CAST(page_consolidation_retry_count AS FLOAT)/CASE WHEN page_consolidation_count=0 THEN 1 ELSE page_consolidation_count END)*100) AS page_consolidation_count_pct,FLOOR((CAST(page_split_retry_count AS FLOAT)/CASE WHEN page_split_count=0 THEN 1 ELSE page_split_count END)*100) AS page_split_count_pct,FLOOR((CAST(key_split_retry_count AS FLOAT)/CASE WHEN key_split_count=0 THEN 1 ELSE key_split_count END)*100) AS key_split_count_pct,FLOOR((CAST(page_merge_retry_count AS FLOAT)/CASE WHEN page_merge_count=0 THEN 1 ELSE page_merge_count END)*100) AS page_merge_count_pct,FLOOR((CAST(key_merge_retry_count AS FLOAT)/CASE WHEN key_merge_count=0 THEN 1 ELSE key_merge_count END)*100) AS key_merge_count_pct FROM sys.dm_db_xtp_nonclustered_index_stats AS xnis (NOLOCK) INNER JOIN sys.dm_db_xtp_index_stats AS xis (NOLOCK) ON xis.[object_id]=xnis.[object_id] AND xis.[index_id]=xnis.[index_id] INNER JOIN sys.indexes AS si (NOLOCK) ON xis.[object_id]=si.[object_id] AND xis.[index_id]=si.[index_id] INNER JOIN sys.objects AS o (NOLOCK) ON si.[object_id]=o.[object_id] INNER JOIN sys.tables AS mst (NOLOCK) ON mst.[object_id]=o.[object_id] INNER JOIN sys.schemas AS t (NOLOCK) ON t.[schema_id]=mst.[schema_id] WHERE o.[type]='U'"
        }
      }
    ],
    "CpuUsage": [
      {
        "type": "SQL",
        "target": {
          "type": "Server",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "query": "DECLARE @ts_now bigint;SELECT @ts_now=ms_ticks FROM sys.dm_os_sys_info (NOLOCK);SELECT 100-ISNULL(SystemIdle,0) AS AVGTotalCPUUsage,AVGSQLCPUUsage,100-ISNULL(SystemIdle,0)-AVGSQLCPUUsage AS AVGCPUUsageByOther FROM(SELECT AVG(SystemIdle) AS SystemIdle,AVG(SQLProcessUtilization) AS AVGSQLCPUUsage FROM(SELECT record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]','int') AS SystemIdle,record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]','int') AS SQLProcessUtilization,[TIMESTAMP] FROM (SELECT [TIMESTAMP],CONVERT(xml,record) AS record FROM sys.dm_os_ring_buffers (NOLOCK) WHERE ring_buffer_type=N'RING_BUFFER_SCHEDULER_MONITOR' AND record LIKE '%<SystemHealth>%' AND @ts_now-[TIMESTAMP]<=7200000) AS xrb ) AS si) AS a"
        }
      }
    ],
    "TF6533SpatialFunctionsUsage": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT DISTINCT 1 AS InUse FROM sys.sql_modules (NOLOCK) WHERE OBJECTPROPERTY([object_id],'IsMSShipped')=0 AND (PATINDEX('%.strelate(%',LOWER([definition]) COLLATE DATABASE_DEFAULT)>1 OR PATINDEX('%.stasbinary(%',LOWER([definition]) COLLATE DATABASE_DEFAULT)>1)",
          "transform": {
            "type": "noData",
            "define": {
              "InUse": 0
            }
          }
        }
      }
    ],
    "FKNotTrusted": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT CONCAT(QUOTENAME(t.name),'.',QUOTENAME(mst.name),'.',QUOTENAME(FKC.name)) AS [constraint_name] FROM sys.foreign_keys FKC (NOLOCK) INNER JOIN sys.objects o (NOLOCK) ON FKC.parent_object_id=o.[object_id] INNER JOIN sys.tables mst (NOLOCK) ON mst.[object_id]=o.[object_id] INNER JOIN sys.schemas t (NOLOCK) ON t.[schema_id]=mst.[schema_id] WHERE o.type='U' AND FKC.is_not_trusted=1 AND FKC.is_not_for_replication=0 GROUP BY o.[schema_id],mst.[object_id],FKC.name,t.name,mst.name UNION ALL SELECT CONCAT(QUOTENAME(t.name),'.',QUOTENAME(mst.name),'.',QUOTENAME(CC.name)) FROM sys.check_constraints CC (NOLOCK) INNER JOIN sys.objects o (NOLOCK) ON CC.parent_object_id=o.[object_id] INNER JOIN sys.tables mst (NOLOCK) ON mst.[object_id]=o.[object_id] INNER JOIN sys.schemas t (NOLOCK) ON t.[schema_id]=mst.[schema_id] WHERE o.type='U' AND CC.is_not_trusted=1 AND CC.is_not_for_replication=0 AND CC.is_disabled=0 GROUP BY t.[schema_id],mst.[object_id],CC.name,t.name,mst.name",
          "transform": {
            "type": "aggregate",
            "map": {
              "constraint_name": "join"
            }
          }
        }
      }
    ],
    "ObjectStatistics": [
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0.3000,)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT DISTINCT CONCAT(t.name,'.',OBJECT_NAME(mst.[object_id])) AS [TableName],ss.name AS [StatName],sp.[rows],sp.modification_counter,sp.rows_sampled FROM sys.objects AS o INNER JOIN sys.tables AS mst ON mst.[object_id]=o.[object_id] INNER JOIN sys.schemas AS t ON t.[schema_id]=mst.[schema_id] INNER JOIN sys.stats AS ss ON ss.[object_id]=mst.[object_id] CROSS APPLY sys.dm_db_stats_properties(ss.[object_id],ss.[stats_id]) AS sp WHERE sp.[rows]>0"
        }
      },
      {
        "type": "SQL",
        "target": {
          "type": "Database",
          "platform": ["Windows", "Linux"],
          "version": "[11.0, 11.0.3000)"
        },
        "implementation": {
          "useDatabase": true,
          "query": "SELECT DISTINCT CONCAT(t.name,'.',OBJECT_NAME(mst.[object_id])) AS [TableName],ss.name AS [StatName],SUM(p.[rows]) AS [rows],si.rowmodctr AS modification_counter,0 AS rows_sampled AS FROM sys.sysindexes AS si INNER JOIN sys.objects AS o ON si.id=o.[object_id] INNER JOIN sys.tables AS mst ON mst.[object_id]=o.[object_id] INNER JOIN sys.schemas AS t ON t.[schema_id]=mst.[schema_id] INNER JOIN sys.stats AS ss ON ss.[object_id]=o.[object_id] INNER JOIN sys.partitions AS p ON p.[object_id]=ss.[object_id] LEFT JOIN sys.indexes i ON si.id=i.[object_id] AND si.indid=i.index_id WHERE o.type<>'S' AND i.name IS NOT NULL GROUP BY mst.[object_id],t.name,rowmodctr,ss.name HAVING SUM(p.[rows])>0"
        }
      }
    ]
  }
}
